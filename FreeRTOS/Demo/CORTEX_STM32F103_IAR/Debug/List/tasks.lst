###############################################################################
#                                                                             #
#                                                       03/Jan/2016  16:21:38 #
# IAR ANSI C/C++ Compiler V6.40.4.24170/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\project\freertos\FreeRTOS\Source\tasks.c              #
#    Command line =  D:\project\freertos\FreeRTOS\Source\tasks.c -D           #
#                    VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN                       #
#                    D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\D #
#                    ebug\List\ --diag_suppress Pa082,pe191 -o                #
#                    D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.4                           #
#                    Evaluation\arm\INC\c\DLib_Config_Full.h" -I              #
#                    D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\. #
#                    \ -I D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_ #
#                    IAR\STM32F10xFWLib\inc\ -I D:\project\freertos\FreeRTOS\ #
#                    Demo\CORTEX_STM32F103_IAR\..\..\Source\include\ -I       #
#                    D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\. #
#                    .\common\include\ -Ol --use_c++_inline                   #
#                    --require_prototypes                                     #
#    List file    =  D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\D #
#                    ebug\List\tasks.lst                                      #
#    Object file  =  D:\project\freertos\FreeRTOS\Demo\CORTEX_STM32F103_IAR\D #
#                    ebug\Obj\tasks.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\project\freertos\FreeRTOS\Source\tasks.c
      1          /*
      2              FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "FreeRTOS.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "StackMacros.h"
     84          
     85          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     86          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     87          header files above, but not in this file, in order to generate the correct
     88          privileged Vs unprivileged linkage and placement. */
     89          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     90          
     91          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     92          functions but without including stdio.h here. */
     93          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     94          	/* At the bottom of this file are two optional functions that can be used
     95          	to generate human readable text from the raw data generated by the
     96          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     97          	for convenience only, and are NOT considered part of the kernel. */
     98          	#include <stdio.h>
     99          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
    100          
    101          /* Sanity check the configuration. */
    102          #if( configUSE_TICKLESS_IDLE != 0 )
    103          	#if( INCLUDE_vTaskSuspend != 1 )
    104          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
    105          	#endif /* INCLUDE_vTaskSuspend */
    106          #endif /* configUSE_TICKLESS_IDLE */
    107          
    108          #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION != 1 ) )
    109          	#error configSUPPORT_STATIC_ALLOCATION must be set to 1 in FreeRTOSConfig.h when the MPU is used.
    110          #endif
    111          
    112          /*
    113           * Defines the size, in words, of the stack allocated to the idle task.
    114           */
    115          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    116          
    117          #if( configUSE_PREEMPTION == 0 )
    118          	/* If the cooperative scheduler is being used then a yield should not be
    119          	performed just because a higher priority task has been woken. */
    120          	#define taskYIELD_IF_USING_PREEMPTION()
    121          #else
    122          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    123          #endif
    124          
    125          /* Bits that can be set in tskTCB->uxStaticAllocationFlags to indicate that the
    126          stack and TCB were statically allocated respectively.  When these are statically
    127          allocated they won't be freed if the task using the stack and TCB gets
    128          deleted. */
    129          #define taskSTATICALLY_ALLOCATED_STACK	( ( UBaseType_t ) 0x01 )
    130          #define taskSTATICALLY_ALLOCATED_TCB	( ( UBaseType_t ) 0x02 )
    131          
    132          /*
    133           * Task control block.  A task control block (TCB) is allocated for each task,
    134           * and stores task state information, including a pointer to the task's context
    135           * (the task's run time environment, including register values)
    136           */
    137          typedef struct tskTaskControlBlock
    138          {
    139          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    140          
    141          	#if ( portUSING_MPU_WRAPPERS == 1 )
    142          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    143          	#endif
    144          
    145          	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    146          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    147          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    148          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    149          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    150          
    151          	#if ( portSTACK_GROWTH > 0 )
    152          		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    153          	#endif
    154          
    155          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    156          		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    157          	#endif
    158          
    159          	#if ( configUSE_TRACE_FACILITY == 1 )
    160          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    161          		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    162          	#endif
    163          
    164          	#if ( configUSE_MUTEXES == 1 )
    165          		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    166          		UBaseType_t		uxMutexesHeld;
    167          	#endif
    168          
    169          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    170          		TaskHookFunction_t pxTaskTag;
    171          	#endif
    172          
    173          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    174          		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    175          	#endif
    176          
    177          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    178          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    179          	#endif
    180          
    181          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    182          		/* Allocate a Newlib reent structure that is specific to this task.
    183          		Note Newlib support has been included by popular demand, but is not
    184          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    185          		responsible for resulting newlib operation.  User must be familiar with
    186          		newlib and must provide system-wide implementations of the necessary
    187          		stubs. Be warned that (at the time of writing) the current newlib design
    188          		implements a system-wide malloc() that must be provided with locks. */
    189          		struct	_reent xNewLib_reent;
    190          	#endif
    191          
    192          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    193          		volatile uint32_t ulNotifiedValue;
    194          		volatile eNotifyValue eNotifyState;
    195          	#endif
    196          
    197          	#if ( configSUPPORT_STATIC_ALLOCATION == 1 )
    198          		UBaseType_t		uxStaticAllocationFlags; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
    199          	#endif
    200          
    201          	} tskTCB;
    202          
    203          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    204          below to enable the use of older kernel aware debuggers. */
    205          typedef tskTCB TCB_t;
    206          
    207          /*
    208           * Some kernel aware debuggers require the data the debugger needs access to to
    209           * be global, rather than file scope.
    210           */
    211          #ifdef portREMOVE_STATIC_QUALIFIER
    212          	#define static
    213          #endif
    214          
    215          /*lint -e956 A manual analysis and inspection has been used to determine which
    216          static variables must be declared volatile. */
    217          
    218          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    219          
    220          /* Lists for ready and blocked tasks. --------------------*/
    221          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    222          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    223          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    224          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    225          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    226          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    227          
    228          #if ( INCLUDE_vTaskDelete == 1 )
    229          
    230          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    231          	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    232          
    233          #endif
    234          
    235          #if ( INCLUDE_vTaskSuspend == 1 )
    236          
    237          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    238          
    239          #endif
    240          
    241          /* Other file private variables. --------------------------------*/
    242          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    243          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    244          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    245          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    246          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    247          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    248          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    249          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    250          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
    251          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    252          
    253          /* Context switches are held pending while the scheduler is suspended.  Also,
    254          interrupts must not manipulate the xGenericListItem of a TCB, or any of the
    255          lists the xGenericListItem can be referenced from, if the scheduler is suspended.
    256          If an interrupt needs to unblock a task while the scheduler is suspended then it
    257          moves the task's event list item into the xPendingReadyList, ready for the
    258          kernel to move the task from the pending ready list into the real ready list
    259          when the scheduler is unsuspended.  The pending ready list itself can only be
    260          accessed from a critical section. */
    261          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    262          
    263          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    264          
    265          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    266          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    267          
    268          #endif
    269          
    270          /*lint +e956 */
    271          
    272          /* Debugging and trace facilities private variables and macros. ------------*/
    273          
    274          /*
    275           * The value used to fill the stack of a task when the task is created.  This
    276           * is used purely for checking the high water mark for tasks.
    277           */
    278          #define tskSTACK_FILL_BYTE	( 0xa5U )
    279          
    280          /*
    281           * Macros used by vListTask to indicate which state a task is in.
    282           */
    283          #define tskBLOCKED_CHAR		( 'B' )
    284          #define tskREADY_CHAR		( 'R' )
    285          #define tskDELETED_CHAR		( 'D' )
    286          #define tskSUSPENDED_CHAR	( 'S' )
    287          
    288          /*-----------------------------------------------------------*/
    289          
    290          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    291          
    292          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    293          	performed in a generic way that is not optimised to any particular
    294          	microcontroller architecture. */
    295          
    296          	/* uxTopReadyPriority holds the priority of the highest priority ready
    297          	state task. */
    298          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    299          	{																									\
    300          		if( ( uxPriority ) > uxTopReadyPriority )														\
    301          		{																								\
    302          			uxTopReadyPriority = ( uxPriority );														\
    303          		}																								\
    304          	} /* taskRECORD_READY_PRIORITY */
    305          
    306          	/*-----------------------------------------------------------*/
    307          
    308          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    309          	{																									\
    310          		/* Find the highest priority queue that contains ready tasks. */								\
    311          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
    312          		{																								\
    313          			configASSERT( uxTopReadyPriority );															\
    314          			--uxTopReadyPriority;																		\
    315          		}																								\
    316          																										\
    317          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    318          		the	same priority get an equal share of the processor time. */									\
    319          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
    320          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    321          
    322          	/*-----------------------------------------------------------*/
    323          
    324          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    325          	they are only required when a port optimised method of task selection is
    326          	being used. */
    327          	#define taskRESET_READY_PRIORITY( uxPriority )
    328          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    329          
    330          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    331          
    332          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    333          	performed in a way that is tailored to the particular microcontroller
    334          	architecture being used. */
    335          
    336          	/* A port optimised version is provided.  Call the port defined macros. */
    337          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    338          
    339          	/*-----------------------------------------------------------*/
    340          
    341          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    342          	{																								\
    343          	UBaseType_t uxTopPriority;																		\
    344          																									\
    345          		/* Find the highest priority list that contains ready tasks. */								\
    346          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    347          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    348          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    349          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    350          
    351          	/*-----------------------------------------------------------*/
    352          
    353          	/* A port optimised version is provided, call it only if the TCB being reset
    354          	is being referenced from a ready list.  If it is referenced from a delayed
    355          	or suspended list then it won't be in a ready list. */
    356          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    357          	{																									\
    358          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    359          		{																								\
    360          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    361          		}																								\
    362          	}
    363          
    364          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    365          
    366          /*-----------------------------------------------------------*/
    367          
    368          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    369          count overflows. */
    370          #define taskSWITCH_DELAYED_LISTS()																	\
    371          {																									\
    372          	List_t *pxTemp;																					\
    373          																									\
    374          	/* The delayed tasks list should be empty when the lists are switched. */						\
    375          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    376          																									\
    377          	pxTemp = pxDelayedTaskList;																		\
    378          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    379          	pxOverflowDelayedTaskList = pxTemp;																\
    380          	xNumOfOverflows++;																				\
    381          	prvResetNextTaskUnblockTime();																	\
    382          }
    383          
    384          /*-----------------------------------------------------------*/
    385          
    386          /*
    387           * Place the task represented by pxTCB into the appropriate ready list for
    388           * the task.  It is inserted at the end of the list.
    389           */
    390          #define prvAddTaskToReadyList( pxTCB )																\
    391          	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
    392          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    393          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) ); \
    394          	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
    395          /*-----------------------------------------------------------*/
    396          
    397          /*
    398           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    399           * where NULL is used to indicate that the handle of the currently executing
    400           * task should be used in place of the parameter.  This macro simply checks to
    401           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    402           */
    403          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    404          
    405          /* The item value of the event list item is normally used to hold the priority
    406          of the task to which it belongs (coded to allow it to be held in reverse
    407          priority order).  However, it is occasionally borrowed for other purposes.  It
    408          is important its value is not updated due to a task priority change while it is
    409          being used for another purpose.  The following bit definition is used to inform
    410          the scheduler that the value should not be changed - in which case it is the
    411          responsibility of whichever module is using the value to ensure it gets set back
    412          to its original value when it is released. */
    413          #if( configUSE_16_BIT_TICKS == 1 )
    414          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    415          #else
    416          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    417          #endif
    418          
    419          /* Callback function prototypes. --------------------------*/
    420          #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
    421          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    422          #endif
    423          
    424          #if( configUSE_TICK_HOOK > 0 )
    425          	extern void vApplicationTickHook( void );
    426          #endif
    427          
    428          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    429          	extern void vApplicationGetIdleTaskMemory( DummyTCB_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint16_t *pusIdleTaskStackSize );
    430          #endif
    431          
    432          /* File private functions. --------------------------------*/
    433          
    434          /*
    435           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    436           * into the TCB structure.
    437           */
    438          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    439          
    440          /**
    441           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    442           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    443           * is in any other state.
    444           */
    445          #if ( INCLUDE_vTaskSuspend == 1 )
    446          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    447          #endif /* INCLUDE_vTaskSuspend */
    448          
    449          /*
    450           * Utility to ready all the lists used by the scheduler.  This is called
    451           * automatically upon the creation of the first task.
    452           */
    453          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    454          
    455          /*
    456           * The idle task, which as all tasks is implemented as a never ending loop.
    457           * The idle task is automatically created and added to the ready lists upon
    458           * creation of the first user task.
    459           *
    460           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    461           * language extensions.  The equivalent prototype for this function is:
    462           *
    463           * void prvIdleTask( void *pvParameters );
    464           *
    465           */
    466          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    467          
    468          /*
    469           * Utility to free all memory allocated by the scheduler to hold a TCB,
    470           * including the stack pointed to by the TCB.
    471           *
    472           * This does not free memory allocated by the task itself (i.e. memory
    473           * allocated by calls to pvPortMalloc from within the tasks application code).
    474           */
    475          #if ( INCLUDE_vTaskDelete == 1 )
    476          
    477          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    478          
    479          #endif
    480          
    481          /*
    482           * Used only by the idle task.  This checks to see if anything has been placed
    483           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    484           * and its TCB deleted.
    485           */
    486          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    487          
    488          /*
    489           * The currently executing task is entering the Blocked state.  Add the task to
    490           * either the current or the overflow delayed task list.
    491           */
    492          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
    493          
    494          /*
    495           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    496           * allocation was successful.
    497           */
    498          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer, TCB_t * const pucTCBBuffer ) PRIVILEGED_FUNCTION;
    499          
    500          /*
    501           * Fills an TaskStatus_t structure with information on each task that is
    502           * referenced from the pxList list (which may be a ready list, a delayed list,
    503           * a suspended list, etc.).
    504           *
    505           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    506           * NORMAL APPLICATION CODE.
    507           */
    508          #if ( configUSE_TRACE_FACILITY == 1 )
    509          
    510          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    511          
    512          #endif
    513          
    514          /*
    515           * When a task is created, the stack of the task is filled with a known value.
    516           * This function determines the 'high water mark' of the task stack by
    517           * determining how much of the stack remains at the original preset value.
    518           */
    519          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    520          
    521          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    522          
    523          #endif
    524          
    525          /*
    526           * Return the amount of time, in ticks, that will pass before the kernel will
    527           * next move a task from the Blocked state to the Running state.
    528           *
    529           * This conditional compilation should use inequality to 0, not equality to 1.
    530           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    531           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    532           * set to a value other than 1.
    533           */
    534          #if ( configUSE_TICKLESS_IDLE != 0 )
    535          
    536          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    537          
    538          #endif
    539          
    540          /*
    541           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    542           * will exit the Blocked state.
    543           */
    544          static void prvResetNextTaskUnblockTime( void );
    545          
    546          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    547          
    548          	/*
    549          	 * Helper function used to pad task names with spaces when printing out
    550          	 * human readable tables of task information.
    551          	 */
    552          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
    553          
    554          #endif
    555          /*-----------------------------------------------------------*/
    556          
    557          BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, DummyTCB_t * const pxTCBBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    558          {
    559          BaseType_t xReturn;
    560          TCB_t * pxNewTCB;
    561          StackType_t *pxTopOfStack;
    562          
    563          	configASSERT( pxTaskCode );
    564          	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
    565          
    566          	/* Allocate the memory required by the TCB and stack for the new task,
    567          	checking that the allocation was successful. */
    568          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer, ( TCB_t* ) pxTCBBuffer ); /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    569          
    570          	if( pxNewTCB != NULL )
    571          	{
    572          		#if( portUSING_MPU_WRAPPERS == 1 )
    573          			/* Should the task be created in privileged mode? */
    574          			BaseType_t xRunPrivileged;
    575          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    576          			{
    577          				xRunPrivileged = pdTRUE;
    578          			}
    579          			else
    580          			{
    581          				xRunPrivileged = pdFALSE;
    582          			}
    583          			uxPriority &= ~portPRIVILEGE_BIT;
    584          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    585          
    586          		/* Calculate the top of stack address.  This depends on whether the
    587          		stack grows from high memory to low (as per the 80x86) or vice versa.
    588          		portSTACK_GROWTH is used to make the result positive or negative as
    589          		required by the port. */
    590          		#if( portSTACK_GROWTH < 0 )
    591          		{
    592          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    593          			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    594          
    595          			/* Check the alignment of the calculated top of stack is correct. */
    596          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    597          		}
    598          		#else /* portSTACK_GROWTH */
    599          		{
    600          			pxTopOfStack = pxNewTCB->pxStack;
    601          
    602          			/* Check the alignment of the stack buffer is correct. */
    603          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    604          
    605          			/* If we want to use stack checking on architectures that use
    606          			a positive stack growth direction then we also need to store the
    607          			other extreme of the stack space. */
    608          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    609          		}
    610          		#endif /* portSTACK_GROWTH */
    611          
    612          		/* Setup the newly allocated TCB with the initial state of the task. */
    613          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    614          
    615          		/* Initialize the TCB stack to look as if the task was already running,
    616          		but had been interrupted by the scheduler.  The return address is set
    617          		to the start of the task function. Once the stack has been initialised
    618          		the	top of stack variable is updated. */
    619          		#if( portUSING_MPU_WRAPPERS == 1 )
    620          		{
    621          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    622          		}
    623          		#else /* portUSING_MPU_WRAPPERS */
    624          		{
    625          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    626          		}
    627          		#endif /* portUSING_MPU_WRAPPERS */
    628          
    629          		if( ( void * ) pxCreatedTask != NULL )
    630          		{
    631          			/* Pass the TCB out - in an anonymous way.  The calling function/
    632          			task can use this as a handle to delete the task later if
    633          			required.*/
    634          			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    635          		}
    636          		else
    637          		{
    638          			mtCOVERAGE_TEST_MARKER();
    639          		}
    640          
    641          		/* Ensure interrupts don't access the task lists while they are being
    642          		updated. */
    643          		taskENTER_CRITICAL();
    644          		{
    645          			uxCurrentNumberOfTasks++;
    646          			if( pxCurrentTCB == NULL )
    647          			{
    648          				/* There are no other tasks, or all the other tasks are in
    649          				the suspended state - make this the current task. */
    650          				pxCurrentTCB =  pxNewTCB;
    651          
    652          				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    653          				{
    654          					/* This is the first task to be created so do the preliminary
    655          					initialisation required.  We will not recover if this call
    656          					fails, but we will report the failure. */
    657          					prvInitialiseTaskLists();
    658          				}
    659          				else
    660          				{
    661          					mtCOVERAGE_TEST_MARKER();
    662          				}
    663          			}
    664          			else
    665          			{
    666          				/* If the scheduler is not already running, make this task the
    667          				current task if it is the highest priority task to be created
    668          				so far. */
    669          				if( xSchedulerRunning == pdFALSE )
    670          				{
    671          					if( pxCurrentTCB->uxPriority <= uxPriority )
    672          					{
    673          						pxCurrentTCB = pxNewTCB;
    674          					}
    675          					else
    676          					{
    677          						mtCOVERAGE_TEST_MARKER();
    678          					}
    679          				}
    680          				else
    681          				{
    682          					mtCOVERAGE_TEST_MARKER();
    683          				}
    684          			}
    685          
    686          			uxTaskNumber++;
    687          
    688          			#if ( configUSE_TRACE_FACILITY == 1 )
    689          			{
    690          				/* Add a counter into the TCB for tracing only. */
    691          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    692          			}
    693          			#endif /* configUSE_TRACE_FACILITY */
    694          			traceTASK_CREATE( pxNewTCB );
    695          
    696          			prvAddTaskToReadyList( pxNewTCB );
    697          
    698          			xReturn = pdPASS;
    699          			portSETUP_TCB( pxNewTCB );
    700          		}
    701          		taskEXIT_CRITICAL();
    702          	}
    703          	else
    704          	{
    705          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    706          		traceTASK_CREATE_FAILED();
    707          	}
    708          
    709          	if( xReturn == pdPASS )
    710          	{
    711          		if( xSchedulerRunning != pdFALSE )
    712          		{
    713          			/* If the created task is of a higher priority than the current task
    714          			then it should run now. */
    715          			if( pxCurrentTCB->uxPriority < uxPriority )
    716          			{
    717          				taskYIELD_IF_USING_PREEMPTION();
    718          			}
    719          			else
    720          			{
    721          				mtCOVERAGE_TEST_MARKER();
    722          			}
    723          		}
    724          		else
    725          		{
    726          			mtCOVERAGE_TEST_MARKER();
    727          		}
    728          	}
    729          
    730          	return xReturn;
    731          }
    732          /*-----------------------------------------------------------*/
    733          
    734          #if ( INCLUDE_vTaskDelete == 1 )
    735          
    736          	void vTaskDelete( TaskHandle_t xTaskToDelete )
    737          	{
    738          	TCB_t *pxTCB;
    739          
    740          		taskENTER_CRITICAL();
    741          		{
    742          			/* If null is passed in here then it is the calling task that is
    743          			being deleted. */
    744          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    745          
    746          			/* Remove task from the ready list. */
    747          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    748          			{
    749          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    750          			}
    751          			else
    752          			{
    753          				mtCOVERAGE_TEST_MARKER();
    754          			}
    755          
    756          			/* Is the task waiting on an event also? */
    757          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    758          			{
    759          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    760          			}
    761          			else
    762          			{
    763          				mtCOVERAGE_TEST_MARKER();
    764          			}
    765          
    766          			if( pxTCB == pxCurrentTCB )
    767          			{
    768          				/* A task is deleting itself.  This cannot complete within the
    769          				task itself, as a context switch to another task is required.
    770          				Place the task in the termination list.  The idle task will
    771          				check the termination list and free up any memory allocated by
    772          				the scheduler for the TCB and stack of the deleted task. */
    773          				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    774          
    775          				/* Increment the ucTasksDeleted variable so the idle task knows
    776          				there is a task that has been deleted and that it should therefore
    777          				check the xTasksWaitingTermination list. */
    778          				++uxDeletedTasksWaitingCleanUp;
    779          			}
    780          			else
    781          			{
    782          				--uxCurrentNumberOfTasks;
    783          				prvDeleteTCB( pxTCB );
    784          			}
    785          
    786          			/* Increment the uxTaskNumber also so kernel aware debuggers can
    787          			detect that the task lists need re-generating. */
    788          			uxTaskNumber++;
    789          
    790          			traceTASK_DELETE( pxTCB );
    791          		}
    792          		taskEXIT_CRITICAL();
    793          
    794          		/* Force a reschedule if it is the currently running task that has just
    795          		been deleted. */
    796          		if( xSchedulerRunning != pdFALSE )
    797          		{
    798          			if( pxTCB == pxCurrentTCB )
    799          			{
    800          				configASSERT( uxSchedulerSuspended == 0 );
    801          
    802          				/* The pre-delete hook is primarily for the Windows simulator,
    803          				in which Windows specific clean up operations are performed,
    804          				after which it is not possible to yield away from this task -
    805          				hence xYieldPending is used to latch that a context switch is
    806          				required. */
    807          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
    808          				portYIELD_WITHIN_API();
    809          			}
    810          			else
    811          			{
    812          				/* Reset the next expected unblock time in case it referred to
    813          				the task that has just been deleted. */
    814          				taskENTER_CRITICAL();
    815          				{
    816          					prvResetNextTaskUnblockTime();
    817          				}
    818          				taskEXIT_CRITICAL();
    819          			}
    820          		}
    821          	}
    822          
    823          #endif /* INCLUDE_vTaskDelete */
    824          /*-----------------------------------------------------------*/
    825          
    826          #if ( INCLUDE_vTaskDelayUntil == 1 )
    827          
    828          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
    829          	{
    830          	TickType_t xTimeToWake;
    831          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    832          
    833          		configASSERT( pxPreviousWakeTime );
    834          		configASSERT( ( xTimeIncrement > 0U ) );
    835          		configASSERT( uxSchedulerSuspended == 0 );
    836          
    837          		vTaskSuspendAll();
    838          		{
    839          			/* Minor optimisation.  The tick count cannot change in this
    840          			block. */
    841          			const TickType_t xConstTickCount = xTickCount;
    842          
    843          			/* Generate the tick time at which the task wants to wake. */
    844          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    845          
    846          			if( xConstTickCount < *pxPreviousWakeTime )
    847          			{
    848          				/* The tick count has overflowed since this function was
    849          				lasted called.  In this case the only time we should ever
    850          				actually delay is if the wake time has also	overflowed,
    851          				and the wake time is greater than the tick time.  When this
    852          				is the case it is as if neither time had overflowed. */
    853          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    854          				{
    855          					xShouldDelay = pdTRUE;
    856          				}
    857          				else
    858          				{
    859          					mtCOVERAGE_TEST_MARKER();
    860          				}
    861          			}
    862          			else
    863          			{
    864          				/* The tick time has not overflowed.  In this case we will
    865          				delay if either the wake time has overflowed, and/or the
    866          				tick time is less than the wake time. */
    867          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    868          				{
    869          					xShouldDelay = pdTRUE;
    870          				}
    871          				else
    872          				{
    873          					mtCOVERAGE_TEST_MARKER();
    874          				}
    875          			}
    876          
    877          			/* Update the wake time ready for the next call. */
    878          			*pxPreviousWakeTime = xTimeToWake;
    879          
    880          			if( xShouldDelay != pdFALSE )
    881          			{
    882          				traceTASK_DELAY_UNTIL();
    883          
    884          				/* Remove the task from the ready list before adding it to the
    885          				blocked list as the same list item is used for both lists. */
    886          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    887          				{
    888          					/* The current task must be in a ready list, so there is
    889          					no need to check, and the port reset macro can be called
    890          					directly. */
    891          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    892          				}
    893          				else
    894          				{
    895          					mtCOVERAGE_TEST_MARKER();
    896          				}
    897          
    898          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    899          			}
    900          			else
    901          			{
    902          				mtCOVERAGE_TEST_MARKER();
    903          			}
    904          		}
    905          		xAlreadyYielded = xTaskResumeAll();
    906          
    907          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    908          		have put ourselves to sleep. */
    909          		if( xAlreadyYielded == pdFALSE )
    910          		{
    911          			portYIELD_WITHIN_API();
    912          		}
    913          		else
    914          		{
    915          			mtCOVERAGE_TEST_MARKER();
    916          		}
    917          	}
    918          
    919          #endif /* INCLUDE_vTaskDelayUntil */
    920          /*-----------------------------------------------------------*/
    921          
    922          #if ( INCLUDE_vTaskDelay == 1 )
    923          
    924          	void vTaskDelay( const TickType_t xTicksToDelay )
    925          	{
    926          	TickType_t xTimeToWake;
    927          	BaseType_t xAlreadyYielded = pdFALSE;
    928          
    929          
    930          		/* A delay time of zero just forces a reschedule. */
    931          		if( xTicksToDelay > ( TickType_t ) 0U )
    932          		{
    933          			configASSERT( uxSchedulerSuspended == 0 );
    934          			vTaskSuspendAll();
    935          			{
    936          				traceTASK_DELAY();
    937          
    938          				/* A task that is removed from the event list while the
    939          				scheduler is suspended will not get placed in the ready
    940          				list or removed from the blocked list until the scheduler
    941          				is resumed.
    942          
    943          				This task cannot be in an event list as it is the currently
    944          				executing task. */
    945          
    946          				/* Calculate the time to wake - this may overflow but this is
    947          				not a problem. */
    948          				xTimeToWake = xTickCount + xTicksToDelay;
    949          
    950          				/* We must remove ourselves from the ready list before adding
    951          				ourselves to the blocked list as the same list item is used for
    952          				both lists. */
    953          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    954          				{
    955          					/* The current task must be in a ready list, so there is
    956          					no need to check, and the port reset macro can be called
    957          					directly. */
    958          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    959          				}
    960          				else
    961          				{
    962          					mtCOVERAGE_TEST_MARKER();
    963          				}
    964          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    965          			}
    966          			xAlreadyYielded = xTaskResumeAll();
    967          		}
    968          		else
    969          		{
    970          			mtCOVERAGE_TEST_MARKER();
    971          		}
    972          
    973          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    974          		have put ourselves to sleep. */
    975          		if( xAlreadyYielded == pdFALSE )
    976          		{
    977          			portYIELD_WITHIN_API();
    978          		}
    979          		else
    980          		{
    981          			mtCOVERAGE_TEST_MARKER();
    982          		}
    983          	}
    984          
    985          #endif /* INCLUDE_vTaskDelay */
    986          /*-----------------------------------------------------------*/
    987          
    988          #if ( INCLUDE_eTaskGetState == 1 )
    989          
    990          	eTaskState eTaskGetState( TaskHandle_t xTask )
    991          	{
    992          	eTaskState eReturn;
    993          	List_t *pxStateList;
    994          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    995          
    996          		configASSERT( pxTCB );
    997          
    998          		if( pxTCB == pxCurrentTCB )
    999          		{
   1000          			/* The task calling this function is querying its own state. */
   1001          			eReturn = eRunning;
   1002          		}
   1003          		else
   1004          		{
   1005          			taskENTER_CRITICAL();
   1006          			{
   1007          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
   1008          			}
   1009          			taskEXIT_CRITICAL();
   1010          
   1011          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   1012          			{
   1013          				/* The task being queried is referenced from one of the Blocked
   1014          				lists. */
   1015          				eReturn = eBlocked;
   1016          			}
   1017          
   1018          			#if ( INCLUDE_vTaskSuspend == 1 )
   1019          				else if( pxStateList == &xSuspendedTaskList )
   1020          				{
   1021          					/* The task being queried is referenced from the suspended
   1022          					list.  Is it genuinely suspended or is it block
   1023          					indefinitely? */
   1024          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1025          					{
   1026          						eReturn = eSuspended;
   1027          					}
   1028          					else
   1029          					{
   1030          						eReturn = eBlocked;
   1031          					}
   1032          				}
   1033          			#endif
   1034          
   1035          			#if ( INCLUDE_vTaskDelete == 1 )
   1036          				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   1037          				{
   1038          					/* The task being queried is referenced from the deleted
   1039          					tasks list, or it is not referenced from any lists at
   1040          					all. */
   1041          					eReturn = eDeleted;
   1042          				}
   1043          			#endif
   1044          
   1045          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1046          			{
   1047          				/* If the task is not in any other state, it must be in the
   1048          				Ready (including pending ready) state. */
   1049          				eReturn = eReady;
   1050          			}
   1051          		}
   1052          
   1053          		return eReturn;
   1054          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1055          
   1056          #endif /* INCLUDE_eTaskGetState */
   1057          /*-----------------------------------------------------------*/
   1058          
   1059          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1060          
   1061          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1062          	{
   1063          	TCB_t *pxTCB;
   1064          	UBaseType_t uxReturn;
   1065          
   1066          		taskENTER_CRITICAL();
   1067          		{
   1068          			/* If null is passed in here then it is the priority of the that
   1069          			called uxTaskPriorityGet() that is being queried. */
   1070          			pxTCB = prvGetTCBFromHandle( xTask );
   1071          			uxReturn = pxTCB->uxPriority;
   1072          		}
   1073          		taskEXIT_CRITICAL();
   1074          
   1075          		return uxReturn;
   1076          	}
   1077          
   1078          #endif /* INCLUDE_uxTaskPriorityGet */
   1079          /*-----------------------------------------------------------*/
   1080          
   1081          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1082          
   1083          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1084          	{
   1085          	TCB_t *pxTCB;
   1086          	UBaseType_t uxReturn, uxSavedInterruptState;
   1087          
   1088          		/* RTOS ports that support interrupt nesting have the concept of a
   1089          		maximum	system call (or maximum API call) interrupt priority.
   1090          		Interrupts that are	above the maximum system call priority are keep
   1091          		permanently enabled, even when the RTOS kernel is in a critical section,
   1092          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1093          		is defined in FreeRTOSConfig.h then
   1094          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1095          		failure if a FreeRTOS API function is called from an interrupt that has
   1096          		been assigned a priority above the configured maximum system call
   1097          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1098          		from interrupts	that have been assigned a priority at or (logically)
   1099          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1100          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1101          		simple as possible.  More information (albeit Cortex-M specific) is
   1102          		provided on the following link:
   1103          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1104          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1105          
   1106          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   1107          		{
   1108          			/* If null is passed in here then it is the priority of the calling
   1109          			task that is being queried. */
   1110          			pxTCB = prvGetTCBFromHandle( xTask );
   1111          			uxReturn = pxTCB->uxPriority;
   1112          		}
   1113          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   1114          
   1115          		return uxReturn;
   1116          	}
   1117          
   1118          #endif /* INCLUDE_uxTaskPriorityGet */
   1119          /*-----------------------------------------------------------*/
   1120          
   1121          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1122          
   1123          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1124          	{
   1125          	TCB_t *pxTCB;
   1126          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1127          	BaseType_t xYieldRequired = pdFALSE;
   1128          
   1129          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1130          
   1131          		/* Ensure the new priority is valid. */
   1132          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1133          		{
   1134          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1135          		}
   1136          		else
   1137          		{
   1138          			mtCOVERAGE_TEST_MARKER();
   1139          		}
   1140          
   1141          		taskENTER_CRITICAL();
   1142          		{
   1143          			/* If null is passed in here then it is the priority of the calling
   1144          			task that is being changed. */
   1145          			pxTCB = prvGetTCBFromHandle( xTask );
   1146          
   1147          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1148          
   1149          			#if ( configUSE_MUTEXES == 1 )
   1150          			{
   1151          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1152          			}
   1153          			#else
   1154          			{
   1155          				uxCurrentBasePriority = pxTCB->uxPriority;
   1156          			}
   1157          			#endif
   1158          
   1159          			if( uxCurrentBasePriority != uxNewPriority )
   1160          			{
   1161          				/* The priority change may have readied a task of higher
   1162          				priority than the calling task. */
   1163          				if( uxNewPriority > uxCurrentBasePriority )
   1164          				{
   1165          					if( pxTCB != pxCurrentTCB )
   1166          					{
   1167          						/* The priority of a task other than the currently
   1168          						running task is being raised.  Is the priority being
   1169          						raised above that of the running task? */
   1170          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1171          						{
   1172          							xYieldRequired = pdTRUE;
   1173          						}
   1174          						else
   1175          						{
   1176          							mtCOVERAGE_TEST_MARKER();
   1177          						}
   1178          					}
   1179          					else
   1180          					{
   1181          						/* The priority of the running task is being raised,
   1182          						but the running task must already be the highest
   1183          						priority task able to run so no yield is required. */
   1184          					}
   1185          				}
   1186          				else if( pxTCB == pxCurrentTCB )
   1187          				{
   1188          					/* Setting the priority of the running task down means
   1189          					there may now be another task of higher priority that
   1190          					is ready to execute. */
   1191          					xYieldRequired = pdTRUE;
   1192          				}
   1193          				else
   1194          				{
   1195          					/* Setting the priority of any other task down does not
   1196          					require a yield as the running task must be above the
   1197          					new priority of the task being modified. */
   1198          				}
   1199          
   1200          				/* Remember the ready list the task might be referenced from
   1201          				before its uxPriority member is changed so the
   1202          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1203          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1204          
   1205          				#if ( configUSE_MUTEXES == 1 )
   1206          				{
   1207          					/* Only change the priority being used if the task is not
   1208          					currently using an inherited priority. */
   1209          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1210          					{
   1211          						pxTCB->uxPriority = uxNewPriority;
   1212          					}
   1213          					else
   1214          					{
   1215          						mtCOVERAGE_TEST_MARKER();
   1216          					}
   1217          
   1218          					/* The base priority gets set whatever. */
   1219          					pxTCB->uxBasePriority = uxNewPriority;
   1220          				}
   1221          				#else
   1222          				{
   1223          					pxTCB->uxPriority = uxNewPriority;
   1224          				}
   1225          				#endif
   1226          
   1227          				/* Only reset the event list item value if the value is not
   1228          				being used for anything else. */
   1229          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1230          				{
   1231          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1232          				}
   1233          				else
   1234          				{
   1235          					mtCOVERAGE_TEST_MARKER();
   1236          				}
   1237          
   1238          				/* If the task is in the blocked or suspended list we need do
   1239          				nothing more than change it's priority variable. However, if
   1240          				the task is in a ready list it needs to be removed and placed
   1241          				in the list appropriate to its new priority. */
   1242          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1243          				{
   1244          					/* The task is currently in its ready list - remove before adding
   1245          					it to it's new ready list.  As we are in a critical section we
   1246          					can do this even if the scheduler is suspended. */
   1247          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1248          					{
   1249          						/* It is known that the task is in its ready list so
   1250          						there is no need to check again and the port level
   1251          						reset macro can be called directly. */
   1252          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1253          					}
   1254          					else
   1255          					{
   1256          						mtCOVERAGE_TEST_MARKER();
   1257          					}
   1258          					prvAddTaskToReadyList( pxTCB );
   1259          				}
   1260          				else
   1261          				{
   1262          					mtCOVERAGE_TEST_MARKER();
   1263          				}
   1264          
   1265          				if( xYieldRequired == pdTRUE )
   1266          				{
   1267          					taskYIELD_IF_USING_PREEMPTION();
   1268          				}
   1269          				else
   1270          				{
   1271          					mtCOVERAGE_TEST_MARKER();
   1272          				}
   1273          
   1274          				/* Remove compiler warning about unused variables when the port
   1275          				optimised task selection is not being used. */
   1276          				( void ) uxPriorityUsedOnEntry;
   1277          			}
   1278          		}
   1279          		taskEXIT_CRITICAL();
   1280          	}
   1281          
   1282          #endif /* INCLUDE_vTaskPrioritySet */
   1283          /*-----------------------------------------------------------*/
   1284          
   1285          #if ( INCLUDE_vTaskSuspend == 1 )
   1286          
   1287          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1288          	{
   1289          	TCB_t *pxTCB;
   1290          
   1291          		taskENTER_CRITICAL();
   1292          		{
   1293          			/* If null is passed in here then it is the running task that is
   1294          			being suspended. */
   1295          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1296          
   1297          			traceTASK_SUSPEND( pxTCB );
   1298          
   1299          			/* Remove task from the ready/delayed list and place in the
   1300          			suspended list. */
   1301          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   1302          			{
   1303          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1304          			}
   1305          			else
   1306          			{
   1307          				mtCOVERAGE_TEST_MARKER();
   1308          			}
   1309          
   1310          			/* Is the task waiting on an event also? */
   1311          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1312          			{
   1313          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1314          			}
   1315          			else
   1316          			{
   1317          				mtCOVERAGE_TEST_MARKER();
   1318          			}
   1319          
   1320          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   1321          		}
   1322          		taskEXIT_CRITICAL();
   1323          
   1324          		if( pxTCB == pxCurrentTCB )
   1325          		{
   1326          			if( xSchedulerRunning != pdFALSE )
   1327          			{
   1328          				/* The current task has just been suspended. */
   1329          				configASSERT( uxSchedulerSuspended == 0 );
   1330          				portYIELD_WITHIN_API();
   1331          			}
   1332          			else
   1333          			{
   1334          				/* The scheduler is not running, but the task that was pointed
   1335          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1336          				must be adjusted to point to a different task. */
   1337          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1338          				{
   1339          					/* No other tasks are ready, so set pxCurrentTCB back to
   1340          					NULL so when the next task is created pxCurrentTCB will
   1341          					be set to point to it no matter what its relative priority
   1342          					is. */
   1343          					pxCurrentTCB = NULL;
   1344          				}
   1345          				else
   1346          				{
   1347          					vTaskSwitchContext();
   1348          				}
   1349          			}
   1350          		}
   1351          		else
   1352          		{
   1353          			if( xSchedulerRunning != pdFALSE )
   1354          			{
   1355          				/* A task other than the currently running task was suspended,
   1356          				reset the next expected unblock time in case it referred to the
   1357          				task that is now in the Suspended state. */
   1358          				taskENTER_CRITICAL();
   1359          				{
   1360          					prvResetNextTaskUnblockTime();
   1361          				}
   1362          				taskEXIT_CRITICAL();
   1363          			}
   1364          			else
   1365          			{
   1366          				mtCOVERAGE_TEST_MARKER();
   1367          			}
   1368          		}
   1369          	}
   1370          
   1371          #endif /* INCLUDE_vTaskSuspend */
   1372          /*-----------------------------------------------------------*/
   1373          
   1374          #if ( INCLUDE_vTaskSuspend == 1 )
   1375          
   1376          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1377          	{
   1378          	BaseType_t xReturn = pdFALSE;
   1379          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1380          
   1381          		/* Accesses xPendingReadyList so must be called from a critical
   1382          		section. */
   1383          
   1384          		/* It does not make sense to check if the calling task is suspended. */
   1385          		configASSERT( xTask );
   1386          
   1387          		/* Is the task being resumed actually in the suspended list? */
   1388          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1389          		{
   1390          			/* Has the task already been resumed from within an ISR? */
   1391          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1392          			{
   1393          				/* Is it in the suspended list because it is in the	Suspended
   1394          				state, or because is is blocked with no timeout? */
   1395          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   1396          				{
   1397          					xReturn = pdTRUE;
   1398          				}
   1399          				else
   1400          				{
   1401          					mtCOVERAGE_TEST_MARKER();
   1402          				}
   1403          			}
   1404          			else
   1405          			{
   1406          				mtCOVERAGE_TEST_MARKER();
   1407          			}
   1408          		}
   1409          		else
   1410          		{
   1411          			mtCOVERAGE_TEST_MARKER();
   1412          		}
   1413          
   1414          		return xReturn;
   1415          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1416          
   1417          #endif /* INCLUDE_vTaskSuspend */
   1418          /*-----------------------------------------------------------*/
   1419          
   1420          #if ( INCLUDE_vTaskSuspend == 1 )
   1421          
   1422          	void vTaskResume( TaskHandle_t xTaskToResume )
   1423          	{
   1424          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1425          
   1426          		/* It does not make sense to resume the calling task. */
   1427          		configASSERT( xTaskToResume );
   1428          
   1429          		/* The parameter cannot be NULL as it is impossible to resume the
   1430          		currently executing task. */
   1431          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1432          		{
   1433          			taskENTER_CRITICAL();
   1434          			{
   1435          				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1436          				{
   1437          					traceTASK_RESUME( pxTCB );
   1438          
   1439          					/* As we are in a critical section we can access the ready
   1440          					lists even if the scheduler is suspended. */
   1441          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1442          					prvAddTaskToReadyList( pxTCB );
   1443          
   1444          					/* We may have just resumed a higher priority task. */
   1445          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1446          					{
   1447          						/* This yield may not cause the task just resumed to run,
   1448          						but will leave the lists in the correct state for the
   1449          						next yield. */
   1450          						taskYIELD_IF_USING_PREEMPTION();
   1451          					}
   1452          					else
   1453          					{
   1454          						mtCOVERAGE_TEST_MARKER();
   1455          					}
   1456          				}
   1457          				else
   1458          				{
   1459          					mtCOVERAGE_TEST_MARKER();
   1460          				}
   1461          			}
   1462          			taskEXIT_CRITICAL();
   1463          		}
   1464          		else
   1465          		{
   1466          			mtCOVERAGE_TEST_MARKER();
   1467          		}
   1468          	}
   1469          
   1470          #endif /* INCLUDE_vTaskSuspend */
   1471          
   1472          /*-----------------------------------------------------------*/
   1473          
   1474          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1475          
   1476          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1477          	{
   1478          	BaseType_t xYieldRequired = pdFALSE;
   1479          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1480          	UBaseType_t uxSavedInterruptStatus;
   1481          
   1482          		configASSERT( xTaskToResume );
   1483          
   1484          		/* RTOS ports that support interrupt nesting have the concept of a
   1485          		maximum	system call (or maximum API call) interrupt priority.
   1486          		Interrupts that are	above the maximum system call priority are keep
   1487          		permanently enabled, even when the RTOS kernel is in a critical section,
   1488          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1489          		is defined in FreeRTOSConfig.h then
   1490          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1491          		failure if a FreeRTOS API function is called from an interrupt that has
   1492          		been assigned a priority above the configured maximum system call
   1493          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1494          		from interrupts	that have been assigned a priority at or (logically)
   1495          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1496          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1497          		simple as possible.  More information (albeit Cortex-M specific) is
   1498          		provided on the following link:
   1499          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1500          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1501          
   1502          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1503          		{
   1504          			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1505          			{
   1506          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1507          
   1508          				/* Check the ready lists can be accessed. */
   1509          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1510          				{
   1511          					/* Ready lists can be accessed so move the task from the
   1512          					suspended list to the ready list directly. */
   1513          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1514          					{
   1515          						xYieldRequired = pdTRUE;
   1516          					}
   1517          					else
   1518          					{
   1519          						mtCOVERAGE_TEST_MARKER();
   1520          					}
   1521          
   1522          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   1523          					prvAddTaskToReadyList( pxTCB );
   1524          				}
   1525          				else
   1526          				{
   1527          					/* The delayed or ready lists cannot be accessed so the task
   1528          					is held in the pending ready list until the scheduler is
   1529          					unsuspended. */
   1530          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1531          				}
   1532          			}
   1533          			else
   1534          			{
   1535          				mtCOVERAGE_TEST_MARKER();
   1536          			}
   1537          		}
   1538          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1539          
   1540          		return xYieldRequired;
   1541          	}
   1542          
   1543          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1544          /*-----------------------------------------------------------*/
   1545          
   1546          void vTaskStartScheduler( void )
   1547          {
   1548          BaseType_t xReturn;
   1549          DummyTCB_t *pxIdleTaskTCBBuffer = NULL;
   1550          StackType_t *pxIdleTaskStackBuffer = NULL;
   1551          uint16_t usIdleTaskStackSize = tskIDLE_STACK_SIZE;
   1552          
   1553          	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   1554          	{
   1555          		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &usIdleTaskStackSize );
   1556          	}
   1557          	#endif /* configSUPPORT_STATIC_ALLOCATION */
   1558          
   1559          	/* Add the idle task at the lowest priority. */
   1560          	xReturn = xTaskGenericCreate( prvIdleTask, "IDLE", usIdleTaskStackSize, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle, pxIdleTaskStackBuffer, pxIdleTaskTCBBuffer, NULL ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1561          
   1562          	#if ( configUSE_TIMERS == 1 )
   1563          	{
   1564          		if( xReturn == pdPASS )
   1565          		{
   1566          			xReturn = xTimerCreateTimerTask();
   1567          		}
   1568          		else
   1569          		{
   1570          			mtCOVERAGE_TEST_MARKER();
   1571          		}
   1572          	}
   1573          	#endif /* configUSE_TIMERS */
   1574          
   1575          	if( xReturn == pdPASS )
   1576          	{
   1577          		/* Interrupts are turned off here, to ensure a tick does not occur
   1578          		before or during the call to xPortStartScheduler().  The stacks of
   1579          		the created tasks contain a status word with interrupts switched on
   1580          		so interrupts will automatically get re-enabled when the first task
   1581          		starts to run. */
   1582          		portDISABLE_INTERRUPTS();
   1583          
   1584          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1585          		{
   1586          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1587          			structure specific to the task that will run first. */
   1588          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1589          		}
   1590          		#endif /* configUSE_NEWLIB_REENTRANT */
   1591          
   1592          		xNextTaskUnblockTime = portMAX_DELAY;
   1593          		xSchedulerRunning = pdTRUE;
   1594          		xTickCount = ( TickType_t ) 0U;
   1595          
   1596          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1597          		macro must be defined to configure the timer/counter used to generate
   1598          		the run time counter time base. */
   1599          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1600          
   1601          		/* Setting up the timer tick is hardware specific and thus in the
   1602          		portable interface. */
   1603          		if( xPortStartScheduler() != pdFALSE )
   1604          		{
   1605          			/* Should not reach here as if the scheduler is running the
   1606          			function will not return. */
   1607          		}
   1608          		else
   1609          		{
   1610          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1611          		}
   1612          	}
   1613          	else
   1614          	{
   1615          		/* This line will only be reached if the kernel could not be started,
   1616          		because there was not enough FreeRTOS heap to create the idle task
   1617          		or the timer task. */
   1618          		configASSERT( xReturn );
   1619          	}
   1620          
   1621          	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0, 
   1622          	meaning xIdleTaskHandle is not used anywhere else. */
   1623          	( void ) xIdleTaskHandle;
   1624          }
   1625          /*-----------------------------------------------------------*/
   1626          
   1627          void vTaskEndScheduler( void )
   1628          {
   1629          	/* Stop the scheduler interrupts and call the portable scheduler end
   1630          	routine so the original ISRs can be restored if necessary.  The port
   1631          	layer must ensure interrupts enable	bit is left in the correct state. */
   1632          	portDISABLE_INTERRUPTS();
   1633          	xSchedulerRunning = pdFALSE;
   1634          	vPortEndScheduler();
   1635          }
   1636          /*----------------------------------------------------------*/
   1637          
   1638          void vTaskSuspendAll( void )
   1639          {
   1640          	/* A critical section is not required as the variable is of type
   1641          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1642          	post in the FreeRTOS support forum before reporting this as a bug! -
   1643          	http://goo.gl/wu4acr */
   1644          	++uxSchedulerSuspended;
   1645          }
   1646          /*----------------------------------------------------------*/
   1647          
   1648          #if ( configUSE_TICKLESS_IDLE != 0 )
   1649          
   1650          	static TickType_t prvGetExpectedIdleTime( void )
   1651          	{
   1652          	TickType_t xReturn;
   1653          	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   1654          
   1655          		/* uxHigherPriorityReadyTasks takes care of the case where
   1656          		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
   1657          		task that are in the Ready state, even though the idle task is
   1658          		running. */
   1659          		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
   1660          		{
   1661          			if( uxTopReadyPriority > tskIDLE_PRIORITY )
   1662          			{
   1663          				uxHigherPriorityReadyTasks = pdTRUE;
   1664          			}
   1665          		}
   1666          		#else
   1667          		{
   1668          			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
   1669          
   1670          			/* When port optimised task selection is used the uxTopReadyPriority
   1671          			variable is used as a bit map.  If bits other than the least
   1672          			significant bit are set then there are tasks that have a priority
   1673          			above the idle priority that are in the Ready state.  This takes
   1674          			care of the case where the co-operative scheduler is in use. */
   1675          			if( uxTopReadyPriority > uxLeastSignificantBit )
   1676          			{
   1677          				uxHigherPriorityReadyTasks = pdTRUE;
   1678          			}
   1679          		}
   1680          		#endif
   1681          
   1682          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1683          		{
   1684          			xReturn = 0;
   1685          		}
   1686          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1687          		{
   1688          			/* There are other idle priority tasks in the ready state.  If
   1689          			time slicing is used then the very next tick interrupt must be
   1690          			processed. */
   1691          			xReturn = 0;
   1692          		}
   1693          		else if( uxHigherPriorityReadyTasks != pdFALSE )
   1694          		{
   1695          			/* There are tasks in the Ready state that have a priority above the
   1696          			idle priority.  This path can only be reached if
   1697          			configUSE_PREEMPTION is 0. */
   1698          			xReturn = 0;
   1699          		}
   1700          		else
   1701          		{
   1702          			xReturn = xNextTaskUnblockTime - xTickCount;
   1703          		}
   1704          
   1705          		return xReturn;
   1706          	}
   1707          
   1708          #endif /* configUSE_TICKLESS_IDLE */
   1709          /*----------------------------------------------------------*/
   1710          
   1711          BaseType_t xTaskResumeAll( void )
   1712          {
   1713          TCB_t *pxTCB;
   1714          BaseType_t xAlreadyYielded = pdFALSE;
   1715          
   1716          	/* If uxSchedulerSuspended is zero then this function does not match a
   1717          	previous call to vTaskSuspendAll(). */
   1718          	configASSERT( uxSchedulerSuspended );
   1719          
   1720          	/* It is possible that an ISR caused a task to be removed from an event
   1721          	list while the scheduler was suspended.  If this was the case then the
   1722          	removed task will have been added to the xPendingReadyList.  Once the
   1723          	scheduler has been resumed it is safe to move all the pending ready
   1724          	tasks from this list into their appropriate ready list. */
   1725          	taskENTER_CRITICAL();
   1726          	{
   1727          		--uxSchedulerSuspended;
   1728          
   1729          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1730          		{
   1731          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   1732          			{
   1733          				/* Move any readied tasks from the pending list into the
   1734          				appropriate ready list. */
   1735          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1736          				{
   1737          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   1738          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1739          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   1740          					prvAddTaskToReadyList( pxTCB );
   1741          
   1742          					/* If the moved task has a priority higher than the current
   1743          					task then a yield must be performed. */
   1744          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1745          					{
   1746          						xYieldPending = pdTRUE;
   1747          					}
   1748          					else
   1749          					{
   1750          						mtCOVERAGE_TEST_MARKER();
   1751          					}
   1752          				}
   1753          
   1754          				/* If any ticks occurred while the scheduler was suspended then
   1755          				they should be processed now.  This ensures the tick count does
   1756          				not	slip, and that any delayed tasks are resumed at the correct
   1757          				time. */
   1758          				if( uxPendedTicks > ( UBaseType_t ) 0U )
   1759          				{
   1760          					while( uxPendedTicks > ( UBaseType_t ) 0U )
   1761          					{
   1762          						if( xTaskIncrementTick() != pdFALSE )
   1763          						{
   1764          							xYieldPending = pdTRUE;
   1765          						}
   1766          						else
   1767          						{
   1768          							mtCOVERAGE_TEST_MARKER();
   1769          						}
   1770          						--uxPendedTicks;
   1771          					}
   1772          				}
   1773          				else
   1774          				{
   1775          					mtCOVERAGE_TEST_MARKER();
   1776          				}
   1777          
   1778          				if( xYieldPending == pdTRUE )
   1779          				{
   1780          					#if( configUSE_PREEMPTION != 0 )
   1781          					{
   1782          						xAlreadyYielded = pdTRUE;
   1783          					}
   1784          					#endif
   1785          					taskYIELD_IF_USING_PREEMPTION();
   1786          				}
   1787          				else
   1788          				{
   1789          					mtCOVERAGE_TEST_MARKER();
   1790          				}
   1791          			}
   1792          		}
   1793          		else
   1794          		{
   1795          			mtCOVERAGE_TEST_MARKER();
   1796          		}
   1797          	}
   1798          	taskEXIT_CRITICAL();
   1799          
   1800          	return xAlreadyYielded;
   1801          }
   1802          /*-----------------------------------------------------------*/
   1803          
   1804          TickType_t xTaskGetTickCount( void )
   1805          {
   1806          TickType_t xTicks;
   1807          
   1808          	/* Critical section required if running on a 16 bit processor. */
   1809          	portTICK_TYPE_ENTER_CRITICAL();
   1810          	{
   1811          		xTicks = xTickCount;
   1812          	}
   1813          	portTICK_TYPE_EXIT_CRITICAL();
   1814          
   1815          	return xTicks;
   1816          }
   1817          /*-----------------------------------------------------------*/
   1818          
   1819          TickType_t xTaskGetTickCountFromISR( void )
   1820          {
   1821          TickType_t xReturn;
   1822          UBaseType_t uxSavedInterruptStatus;
   1823          
   1824          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1825          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1826          	above the maximum system call priority are kept permanently enabled, even
   1827          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1828          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   1829          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1830          	failure if a FreeRTOS API function is called from an interrupt that has been
   1831          	assigned a priority above the configured maximum system call priority.
   1832          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1833          	that have been assigned a priority at or (logically) below the maximum
   1834          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1835          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1836          	More information (albeit Cortex-M specific) is provided on the following
   1837          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1838          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1839          
   1840          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   1841          	{
   1842          		xReturn = xTickCount;
   1843          	}
   1844          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1845          
   1846          	return xReturn;
   1847          }
   1848          /*-----------------------------------------------------------*/
   1849          
   1850          UBaseType_t uxTaskGetNumberOfTasks( void )
   1851          {
   1852          	/* A critical section is not required because the variables are of type
   1853          	BaseType_t. */
   1854          	return uxCurrentNumberOfTasks;
   1855          }
   1856          /*-----------------------------------------------------------*/
   1857          
   1858          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1859          
   1860          	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   1861          	{
   1862          	TCB_t *pxTCB;
   1863          
   1864          		/* If null is passed in here then the name of the calling task is being queried. */
   1865          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1866          		configASSERT( pxTCB );
   1867          		return &( pxTCB->pcTaskName[ 0 ] );
   1868          	}
   1869          
   1870          #endif /* INCLUDE_pcTaskGetTaskName */
   1871          /*-----------------------------------------------------------*/
   1872          
   1873          #if ( configUSE_TRACE_FACILITY == 1 )
   1874          
   1875          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   1876          	{
   1877          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   1878          
   1879          		vTaskSuspendAll();
   1880          		{
   1881          			/* Is there a space in the array for each task in the system? */
   1882          			if( uxArraySize >= uxCurrentNumberOfTasks )
   1883          			{
   1884          				/* Fill in an TaskStatus_t structure with information on each
   1885          				task in the Ready state. */
   1886          				do
   1887          				{
   1888          					uxQueue--;
   1889          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1890          
   1891          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1892          
   1893          				/* Fill in an TaskStatus_t structure with information on each
   1894          				task in the Blocked state. */
   1895          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   1896          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   1897          
   1898          				#if( INCLUDE_vTaskDelete == 1 )
   1899          				{
   1900          					/* Fill in an TaskStatus_t structure with information on
   1901          					each task that has been deleted but not yet cleaned up. */
   1902          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1903          				}
   1904          				#endif
   1905          
   1906          				#if ( INCLUDE_vTaskSuspend == 1 )
   1907          				{
   1908          					/* Fill in an TaskStatus_t structure with information on
   1909          					each task in the Suspended state. */
   1910          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1911          				}
   1912          				#endif
   1913          
   1914          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1915          				{
   1916          					if( pulTotalRunTime != NULL )
   1917          					{
   1918          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1919          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1920          						#else
   1921          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1922          						#endif
   1923          					}
   1924          				}
   1925          				#else
   1926          				{
   1927          					if( pulTotalRunTime != NULL )
   1928          					{
   1929          						*pulTotalRunTime = 0;
   1930          					}
   1931          				}
   1932          				#endif
   1933          			}
   1934          			else
   1935          			{
   1936          				mtCOVERAGE_TEST_MARKER();
   1937          			}
   1938          		}
   1939          		( void ) xTaskResumeAll();
   1940          
   1941          		return uxTask;
   1942          	}
   1943          
   1944          #endif /* configUSE_TRACE_FACILITY */
   1945          /*----------------------------------------------------------*/
   1946          
   1947          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1948          
   1949          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   1950          	{
   1951          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1952          		started, then xIdleTaskHandle will be NULL. */
   1953          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1954          		return xIdleTaskHandle;
   1955          	}
   1956          
   1957          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1958          /*----------------------------------------------------------*/
   1959          
   1960          /* This conditional compilation should use inequality to 0, not equality to 1.
   1961          This is to ensure vTaskStepTick() is available when user defined low power mode
   1962          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1963          1. */
   1964          #if ( configUSE_TICKLESS_IDLE != 0 )
   1965          
   1966          	void vTaskStepTick( const TickType_t xTicksToJump )
   1967          	{
   1968          		/* Correct the tick count value after a period during which the tick
   1969          		was suppressed.  Note this does *not* call the tick hook function for
   1970          		each stepped tick. */
   1971          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1972          		xTickCount += xTicksToJump;
   1973          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1974          	}
   1975          
   1976          #endif /* configUSE_TICKLESS_IDLE */
   1977          /*----------------------------------------------------------*/
   1978          
   1979          BaseType_t xTaskIncrementTick( void )
   1980          {
   1981          TCB_t * pxTCB;
   1982          TickType_t xItemValue;
   1983          BaseType_t xSwitchRequired = pdFALSE;
   1984          
   1985          	/* Called by the portable layer each time a tick interrupt occurs.
   1986          	Increments the tick then checks to see if the new tick value will cause any
   1987          	tasks to be unblocked. */
   1988          	traceTASK_INCREMENT_TICK( xTickCount );
   1989          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1990          	{
   1991          		/* Increment the RTOS tick, switching the delayed and overflowed
   1992          		delayed lists if it wraps to 0. */
   1993          		++xTickCount;
   1994          
   1995          		{
   1996          			/* Minor optimisation.  The tick count cannot change in this
   1997          			block. */
   1998          			const TickType_t xConstTickCount = xTickCount;
   1999          
   2000          			if( xConstTickCount == ( TickType_t ) 0U )
   2001          			{
   2002          				taskSWITCH_DELAYED_LISTS();
   2003          			}
   2004          			else
   2005          			{
   2006          				mtCOVERAGE_TEST_MARKER();
   2007          			}
   2008          
   2009          			/* See if this tick has made a timeout expire.  Tasks are stored in
   2010          			the	queue in the order of their wake time - meaning once one task
   2011          			has been found whose block time has not expired there is no need to
   2012          			look any further down the list. */
   2013          			if( xConstTickCount >= xNextTaskUnblockTime )
   2014          			{
   2015          				for( ;; )
   2016          				{
   2017          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2018          					{
   2019          						/* The delayed list is empty.  Set xNextTaskUnblockTime
   2020          						to the maximum possible value so it is extremely
   2021          						unlikely that the
   2022          						if( xTickCount >= xNextTaskUnblockTime ) test will pass
   2023          						next time through. */
   2024          						xNextTaskUnblockTime = portMAX_DELAY;
   2025          						break;
   2026          					}
   2027          					else
   2028          					{
   2029          						/* The delayed list is not empty, get the value of the
   2030          						item at the head of the delayed list.  This is the time
   2031          						at which the task at the head of the delayed list must
   2032          						be removed from the Blocked state. */
   2033          						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   2034          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   2035          
   2036          						if( xConstTickCount < xItemValue )
   2037          						{
   2038          							/* It is not time to unblock this item yet, but the
   2039          							item value is the time at which the task at the head
   2040          							of the blocked list must be removed from the Blocked
   2041          							state -	so record the item value in
   2042          							xNextTaskUnblockTime. */
   2043          							xNextTaskUnblockTime = xItemValue;
   2044          							break;
   2045          						}
   2046          						else
   2047          						{
   2048          							mtCOVERAGE_TEST_MARKER();
   2049          						}
   2050          
   2051          						/* It is time to remove the item from the Blocked state. */
   2052          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   2053          
   2054          						/* Is the task waiting on an event also?  If so remove
   2055          						it from the event list. */
   2056          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2057          						{
   2058          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2059          						}
   2060          						else
   2061          						{
   2062          							mtCOVERAGE_TEST_MARKER();
   2063          						}
   2064          
   2065          						/* Place the unblocked task into the appropriate ready
   2066          						list. */
   2067          						prvAddTaskToReadyList( pxTCB );
   2068          
   2069          						/* A task being unblocked cannot cause an immediate
   2070          						context switch if preemption is turned off. */
   2071          						#if (  configUSE_PREEMPTION == 1 )
   2072          						{
   2073          							/* Preemption is on, but a context switch should
   2074          							only be performed if the unblocked task has a
   2075          							priority that is equal to or higher than the
   2076          							currently executing task. */
   2077          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2078          							{
   2079          								xSwitchRequired = pdTRUE;
   2080          							}
   2081          							else
   2082          							{
   2083          								mtCOVERAGE_TEST_MARKER();
   2084          							}
   2085          						}
   2086          						#endif /* configUSE_PREEMPTION */
   2087          					}
   2088          				}
   2089          			}
   2090          		}
   2091          
   2092          		/* Tasks of equal priority to the currently running task will share
   2093          		processing time (time slice) if preemption is on, and the application
   2094          		writer has not explicitly turned time slicing off. */
   2095          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2096          		{
   2097          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2098          			{
   2099          				xSwitchRequired = pdTRUE;
   2100          			}
   2101          			else
   2102          			{
   2103          				mtCOVERAGE_TEST_MARKER();
   2104          			}
   2105          		}
   2106          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2107          
   2108          		#if ( configUSE_TICK_HOOK == 1 )
   2109          		{
   2110          			/* Guard against the tick hook being called when the pended tick
   2111          			count is being unwound (when the scheduler is being unlocked). */
   2112          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2113          			{
   2114          				vApplicationTickHook();
   2115          			}
   2116          			else
   2117          			{
   2118          				mtCOVERAGE_TEST_MARKER();
   2119          			}
   2120          		}
   2121          		#endif /* configUSE_TICK_HOOK */
   2122          	}
   2123          	else
   2124          	{
   2125          		++uxPendedTicks;
   2126          
   2127          		/* The tick hook gets called at regular intervals, even if the
   2128          		scheduler is locked. */
   2129          		#if ( configUSE_TICK_HOOK == 1 )
   2130          		{
   2131          			vApplicationTickHook();
   2132          		}
   2133          		#endif
   2134          	}
   2135          
   2136          	#if ( configUSE_PREEMPTION == 1 )
   2137          	{
   2138          		if( xYieldPending != pdFALSE )
   2139          		{
   2140          			xSwitchRequired = pdTRUE;
   2141          		}
   2142          		else
   2143          		{
   2144          			mtCOVERAGE_TEST_MARKER();
   2145          		}
   2146          	}
   2147          	#endif /* configUSE_PREEMPTION */
   2148          
   2149          	return xSwitchRequired;
   2150          }
   2151          /*-----------------------------------------------------------*/
   2152          
   2153          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2154          
   2155          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2156          	{
   2157          	TCB_t *xTCB;
   2158          
   2159          		/* If xTask is NULL then it is the task hook of the calling task that is
   2160          		getting set. */
   2161          		if( xTask == NULL )
   2162          		{
   2163          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2164          		}
   2165          		else
   2166          		{
   2167          			xTCB = ( TCB_t * ) xTask;
   2168          		}
   2169          
   2170          		/* Save the hook function in the TCB.  A critical section is required as
   2171          		the value can be accessed from an interrupt. */
   2172          		taskENTER_CRITICAL();
   2173          			xTCB->pxTaskTag = pxHookFunction;
   2174          		taskEXIT_CRITICAL();
   2175          	}
   2176          
   2177          #endif /* configUSE_APPLICATION_TASK_TAG */
   2178          /*-----------------------------------------------------------*/
   2179          
   2180          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2181          
   2182          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2183          	{
   2184          	TCB_t *xTCB;
   2185          	TaskHookFunction_t xReturn;
   2186          
   2187          		/* If xTask is NULL then we are setting our own task hook. */
   2188          		if( xTask == NULL )
   2189          		{
   2190          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2191          		}
   2192          		else
   2193          		{
   2194          			xTCB = ( TCB_t * ) xTask;
   2195          		}
   2196          
   2197          		/* Save the hook function in the TCB.  A critical section is required as
   2198          		the value can be accessed from an interrupt. */
   2199          		taskENTER_CRITICAL();
   2200          		{
   2201          			xReturn = xTCB->pxTaskTag;
   2202          		}
   2203          		taskEXIT_CRITICAL();
   2204          
   2205          		return xReturn;
   2206          	}
   2207          
   2208          #endif /* configUSE_APPLICATION_TASK_TAG */
   2209          /*-----------------------------------------------------------*/
   2210          
   2211          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2212          
   2213          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2214          	{
   2215          	TCB_t *xTCB;
   2216          	BaseType_t xReturn;
   2217          
   2218          		/* If xTask is NULL then we are calling our own task hook. */
   2219          		if( xTask == NULL )
   2220          		{
   2221          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2222          		}
   2223          		else
   2224          		{
   2225          			xTCB = ( TCB_t * ) xTask;
   2226          		}
   2227          
   2228          		if( xTCB->pxTaskTag != NULL )
   2229          		{
   2230          			xReturn = xTCB->pxTaskTag( pvParameter );
   2231          		}
   2232          		else
   2233          		{
   2234          			xReturn = pdFAIL;
   2235          		}
   2236          
   2237          		return xReturn;
   2238          	}
   2239          
   2240          #endif /* configUSE_APPLICATION_TASK_TAG */
   2241          /*-----------------------------------------------------------*/
   2242          
   2243          void vTaskSwitchContext( void )
   2244          {
   2245          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2246          	{
   2247          		/* The scheduler is currently suspended - do not allow a context
   2248          		switch. */
   2249          		xYieldPending = pdTRUE;
   2250          	}
   2251          	else
   2252          	{
   2253          		xYieldPending = pdFALSE;
   2254          		traceTASK_SWITCHED_OUT();
   2255          
   2256          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2257          		{
   2258          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2259          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2260          				#else
   2261          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2262          				#endif
   2263          
   2264          				/* Add the amount of time the task has been running to the
   2265          				accumulated time so far.  The time the task started running was
   2266          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2267          				protection here so count values are only valid until the timer
   2268          				overflows.  The guard against negative values is to protect
   2269          				against suspect run time stat counter implementations - which
   2270          				are provided by the application, not the kernel. */
   2271          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2272          				{
   2273          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2274          				}
   2275          				else
   2276          				{
   2277          					mtCOVERAGE_TEST_MARKER();
   2278          				}
   2279          				ulTaskSwitchedInTime = ulTotalRunTime;
   2280          		}
   2281          		#endif /* configGENERATE_RUN_TIME_STATS */
   2282          
   2283          		/* Check for stack overflow, if configured. */
   2284          		taskCHECK_FOR_STACK_OVERFLOW();
   2285          
   2286          		/* Select a new task to run using either the generic C or port
   2287          		optimised asm code. */
   2288          		taskSELECT_HIGHEST_PRIORITY_TASK();
   2289          		traceTASK_SWITCHED_IN();
   2290          
   2291          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2292          		{
   2293          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2294          			structure specific to this task. */
   2295          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2296          		}
   2297          		#endif /* configUSE_NEWLIB_REENTRANT */
   2298          	}
   2299          }
   2300          /*-----------------------------------------------------------*/
   2301          
   2302          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2303          {
   2304          TickType_t xTimeToWake;
   2305          
   2306          	configASSERT( pxEventList );
   2307          
   2308          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2309          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2310          
   2311          	/* Place the event list item of the TCB in the appropriate event list.
   2312          	This is placed in the list in priority order so the highest priority task
   2313          	is the first to be woken by the event.  The queue that contains the event
   2314          	list is locked, preventing simultaneous access from interrupts. */
   2315          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2316          
   2317          	/* The task must be removed from from the ready list before it is added to
   2318          	the blocked list as the same list item is used for both lists.  Exclusive
   2319          	access to the ready lists guaranteed because the scheduler is locked. */
   2320          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2321          	{
   2322          		/* The current task must be in a ready list, so there is no need to
   2323          		check, and the port reset macro can be called directly. */
   2324          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2325          	}
   2326          	else
   2327          	{
   2328          		mtCOVERAGE_TEST_MARKER();
   2329          	}
   2330          
   2331          	#if ( INCLUDE_vTaskSuspend == 1 )
   2332          	{
   2333          		if( xTicksToWait == portMAX_DELAY )
   2334          		{
   2335          			/* Add the task to the suspended task list instead of a delayed task
   2336          			list to ensure the task is not woken by a timing event.  It will
   2337          			block indefinitely. */
   2338          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2339          		}
   2340          		else
   2341          		{
   2342          			/* Calculate the time at which the task should be woken if the event
   2343          			does not occur.  This may overflow but this doesn't matter, the
   2344          			scheduler will handle it. */
   2345          			xTimeToWake = xTickCount + xTicksToWait;
   2346          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2347          		}
   2348          	}
   2349          	#else /* INCLUDE_vTaskSuspend */
   2350          	{
   2351          			/* Calculate the time at which the task should be woken if the event does
   2352          			not occur.  This may overflow but this doesn't matter, the scheduler
   2353          			will handle it. */
   2354          			xTimeToWake = xTickCount + xTicksToWait;
   2355          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2356          	}
   2357          	#endif /* INCLUDE_vTaskSuspend */
   2358          }
   2359          /*-----------------------------------------------------------*/
   2360          
   2361          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2362          {
   2363          TickType_t xTimeToWake;
   2364          
   2365          	configASSERT( pxEventList );
   2366          
   2367          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2368          	the event groups implementation. */
   2369          	configASSERT( uxSchedulerSuspended != 0 );
   2370          
   2371          	/* Store the item value in the event list item.  It is safe to access the
   2372          	event list item here as interrupts won't access the event list item of a
   2373          	task that is not in the Blocked state. */
   2374          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2375          
   2376          	/* Place the event list item of the TCB at the end of the appropriate event
   2377          	list.  It is safe to access the event list here because it is part of an
   2378          	event group implementation - and interrupts don't access event groups
   2379          	directly (instead they access them indirectly by pending function calls to
   2380          	the task level). */
   2381          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2382          
   2383          	/* The task must be removed from the ready list before it is added to the
   2384          	blocked list.  Exclusive access can be assured to the ready list as the
   2385          	scheduler is locked. */
   2386          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2387          	{
   2388          		/* The current task must be in a ready list, so there is no need to
   2389          		check, and the port reset macro can be called directly. */
   2390          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2391          	}
   2392          	else
   2393          	{
   2394          		mtCOVERAGE_TEST_MARKER();
   2395          	}
   2396          
   2397          	#if ( INCLUDE_vTaskSuspend == 1 )
   2398          	{
   2399          		if( xTicksToWait == portMAX_DELAY )
   2400          		{
   2401          			/* Add the task to the suspended task list instead of a delayed task
   2402          			list to ensure it is not woken by a timing event.  It will block
   2403          			indefinitely. */
   2404          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2405          		}
   2406          		else
   2407          		{
   2408          			/* Calculate the time at which the task should be woken if the event
   2409          			does not occur.  This may overflow but this doesn't matter, the
   2410          			kernel will manage it correctly. */
   2411          			xTimeToWake = xTickCount + xTicksToWait;
   2412          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2413          		}
   2414          	}
   2415          	#else /* INCLUDE_vTaskSuspend */
   2416          	{
   2417          			/* Calculate the time at which the task should be woken if the event does
   2418          			not occur.  This may overflow but this doesn't matter, the kernel
   2419          			will manage it correctly. */
   2420          			xTimeToWake = xTickCount + xTicksToWait;
   2421          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2422          	}
   2423          	#endif /* INCLUDE_vTaskSuspend */
   2424          }
   2425          /*-----------------------------------------------------------*/
   2426          
   2427          #if configUSE_TIMERS == 1
   2428          
   2429          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   2430          	{
   2431          	TickType_t xTimeToWake;
   2432          
   2433          		configASSERT( pxEventList );
   2434          
   2435          		/* This function should not be called by application code hence the
   2436          		'Restricted' in its name.  It is not part of the public API.  It is
   2437          		designed for use by kernel code, and has special calling requirements -
   2438          		it should be called with the scheduler suspended. */
   2439          
   2440          
   2441          		/* Place the event list item of the TCB in the appropriate event list.
   2442          		In this case it is assume that this is the only task that is going to
   2443          		be waiting on this event list, so the faster vListInsertEnd() function
   2444          		can be used in place of vListInsert. */
   2445          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2446          
   2447          		/* We must remove this task from the ready list before adding it to the
   2448          		blocked list as the same list item is used for both lists.  This
   2449          		function is called with the scheduler locked so interrupts will not
   2450          		access the lists at the same time. */
   2451          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   2452          		{
   2453          			/* The current task must be in a ready list, so there is no need to
   2454          			check, and the port reset macro can be called directly. */
   2455          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2456          		}
   2457          		else
   2458          		{
   2459          			mtCOVERAGE_TEST_MARKER();
   2460          		}
   2461          
   2462          		/* If vTaskSuspend() is available then the suspended task list is also
   2463          		available and a task that is blocking indefinitely can enter the
   2464          		suspended state (it is not really suspended as it will re-enter the
   2465          		Ready state when the event it is waiting indefinitely for occurs).
   2466          		Blocking indefinitely is useful when using tickless idle mode as when
   2467          		all tasks are blocked indefinitely all timers can be turned off. */
   2468          		#if( INCLUDE_vTaskSuspend == 1 )
   2469          		{
   2470          			if( xWaitIndefinitely == pdTRUE )
   2471          			{
   2472          				/* Add the task to the suspended task list instead of a delayed
   2473          				task list to ensure the task is not woken by a timing event.  It
   2474          				will block indefinitely. */
   2475          				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   2476          			}
   2477          			else
   2478          			{
   2479          				/* Calculate the time at which the task should be woken if the
   2480          				event does not occur.  This may overflow but this doesn't
   2481          				matter. */
   2482          				xTimeToWake = xTickCount + xTicksToWait;
   2483          				traceTASK_DELAY_UNTIL();
   2484          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   2485          			}
   2486          		}
   2487          		#else
   2488          		{
   2489          			/* Calculate the time at which the task should be woken if the event
   2490          			does not occur.  This may overflow but this doesn't matter. */
   2491          			xTimeToWake = xTickCount + xTicksToWait;
   2492          			traceTASK_DELAY_UNTIL();
   2493          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2494          
   2495          			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
   2496          			defined. */
   2497          			( void ) xWaitIndefinitely;
   2498          		}
   2499          		#endif
   2500          	}
   2501          
   2502          #endif /* configUSE_TIMERS */
   2503          /*-----------------------------------------------------------*/
   2504          
   2505          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2506          {
   2507          TCB_t *pxUnblockedTCB;
   2508          BaseType_t xReturn;
   2509          
   2510          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2511          	called from a critical section within an ISR. */
   2512          
   2513          	/* The event list is sorted in priority order, so the first in the list can
   2514          	be removed as it is known to be the highest priority.  Remove the TCB from
   2515          	the delayed list, and add it to the ready list.
   2516          
   2517          	If an event is for a queue that is locked then this function will never
   2518          	get called - the lock count on the queue will get modified instead.  This
   2519          	means exclusive access to the event list is guaranteed here.
   2520          
   2521          	This function assumes that a check has already been made to ensure that
   2522          	pxEventList is not empty. */
   2523          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   2524          	configASSERT( pxUnblockedTCB );
   2525          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   2526          
   2527          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2528          	{
   2529          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2530          		prvAddTaskToReadyList( pxUnblockedTCB );
   2531          	}
   2532          	else
   2533          	{
   2534          		/* The delayed and ready lists cannot be accessed, so hold this task
   2535          		pending until the scheduler is resumed. */
   2536          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   2537          	}
   2538          
   2539          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2540          	{
   2541          		/* Return true if the task removed from the event list has a higher
   2542          		priority than the calling task.  This allows the calling task to know if
   2543          		it should force a context switch now. */
   2544          		xReturn = pdTRUE;
   2545          
   2546          		/* Mark that a yield is pending in case the user is not using the
   2547          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2548          		xYieldPending = pdTRUE;
   2549          	}
   2550          	else
   2551          	{
   2552          		xReturn = pdFALSE;
   2553          	}
   2554          
   2555          	#if( configUSE_TICKLESS_IDLE != 0 )
   2556          	{
   2557          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   2558          		might be set to the blocked task's time out time.  If the task is
   2559          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   2560          		normally left unchanged, because it is automatically reset to a new
   2561          		value when the tick count equals xNextTaskUnblockTime.  However if
   2562          		tickless idling is used it might be more important to enter sleep mode
   2563          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   2564          		ensure it is updated at the earliest possible time. */
   2565          		prvResetNextTaskUnblockTime();
   2566          	}
   2567          	#endif
   2568          
   2569          	return xReturn;
   2570          }
   2571          /*-----------------------------------------------------------*/
   2572          
   2573          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2574          {
   2575          TCB_t *pxUnblockedTCB;
   2576          BaseType_t xReturn;
   2577          
   2578          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2579          	the event flags implementation. */
   2580          	configASSERT( uxSchedulerSuspended != pdFALSE );
   2581          
   2582          	/* Store the new item value in the event list. */
   2583          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2584          
   2585          	/* Remove the event list form the event flag.  Interrupts do not access
   2586          	event flags. */
   2587          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   2588          	configASSERT( pxUnblockedTCB );
   2589          	( void ) uxListRemove( pxEventListItem );
   2590          
   2591          	/* Remove the task from the delayed list and add it to the ready list.  The
   2592          	scheduler is suspended so interrupts will not be accessing the ready
   2593          	lists. */
   2594          	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   2595          	prvAddTaskToReadyList( pxUnblockedTCB );
   2596          
   2597          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2598          	{
   2599          		/* Return true if the task removed from the event list has
   2600          		a higher priority than the calling task.  This allows
   2601          		the calling task to know if it should force a context
   2602          		switch now. */
   2603          		xReturn = pdTRUE;
   2604          
   2605          		/* Mark that a yield is pending in case the user is not using the
   2606          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2607          		xYieldPending = pdTRUE;
   2608          	}
   2609          	else
   2610          	{
   2611          		xReturn = pdFALSE;
   2612          	}
   2613          
   2614          	return xReturn;
   2615          }
   2616          /*-----------------------------------------------------------*/
   2617          
   2618          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   2619          {
   2620          	configASSERT( pxTimeOut );
   2621          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2622          	pxTimeOut->xTimeOnEntering = xTickCount;
   2623          }
   2624          /*-----------------------------------------------------------*/
   2625          
   2626          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   2627          {
   2628          BaseType_t xReturn;
   2629          
   2630          	configASSERT( pxTimeOut );
   2631          	configASSERT( pxTicksToWait );
   2632          
   2633          	taskENTER_CRITICAL();
   2634          	{
   2635          		/* Minor optimisation.  The tick count cannot change in this block. */
   2636          		const TickType_t xConstTickCount = xTickCount;
   2637          
   2638          		#if ( INCLUDE_vTaskSuspend == 1 )
   2639          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2640          			the maximum block time then the task should block indefinitely, and
   2641          			therefore never time out. */
   2642          			if( *pxTicksToWait == portMAX_DELAY )
   2643          			{
   2644          				xReturn = pdFALSE;
   2645          			}
   2646          			else /* We are not blocking indefinitely, perform the checks below. */
   2647          		#endif
   2648          
   2649          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   2650          		{
   2651          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2652          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2653          			It must have wrapped all the way around and gone past us again. This
   2654          			passed since vTaskSetTimeout() was called. */
   2655          			xReturn = pdTRUE;
   2656          		}
   2657          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   2658          		{
   2659          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2660          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   2661          			vTaskSetTimeOutState( pxTimeOut );
   2662          			xReturn = pdFALSE;
   2663          		}
   2664          		else
   2665          		{
   2666          			xReturn = pdTRUE;
   2667          		}
   2668          	}
   2669          	taskEXIT_CRITICAL();
   2670          
   2671          	return xReturn;
   2672          }
   2673          /*-----------------------------------------------------------*/
   2674          
   2675          void vTaskMissedYield( void )
   2676          {
   2677          	xYieldPending = pdTRUE;
   2678          }
   2679          /*-----------------------------------------------------------*/
   2680          
   2681          #if ( configUSE_TRACE_FACILITY == 1 )
   2682          
   2683          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   2684          	{
   2685          	UBaseType_t uxReturn;
   2686          	TCB_t *pxTCB;
   2687          
   2688          		if( xTask != NULL )
   2689          		{
   2690          			pxTCB = ( TCB_t * ) xTask;
   2691          			uxReturn = pxTCB->uxTaskNumber;
   2692          		}
   2693          		else
   2694          		{
   2695          			uxReturn = 0U;
   2696          		}
   2697          
   2698          		return uxReturn;
   2699          	}
   2700          
   2701          #endif /* configUSE_TRACE_FACILITY */
   2702          /*-----------------------------------------------------------*/
   2703          
   2704          #if ( configUSE_TRACE_FACILITY == 1 )
   2705          
   2706          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   2707          	{
   2708          	TCB_t *pxTCB;
   2709          
   2710          		if( xTask != NULL )
   2711          		{
   2712          			pxTCB = ( TCB_t * ) xTask;
   2713          			pxTCB->uxTaskNumber = uxHandle;
   2714          		}
   2715          	}
   2716          
   2717          #endif /* configUSE_TRACE_FACILITY */
   2718          
   2719          /*
   2720           * -----------------------------------------------------------
   2721           * The Idle task.
   2722           * ----------------------------------------------------------
   2723           *
   2724           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2725           * language extensions.  The equivalent prototype for this function is:
   2726           *
   2727           * void prvIdleTask( void *pvParameters );
   2728           *
   2729           */
   2730          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2731          {
   2732          	/* Stop warnings. */
   2733          	( void ) pvParameters;
   2734          
   2735          	for( ;; )
   2736          	{
   2737          		/* See if any tasks have been deleted. */
   2738          		prvCheckTasksWaitingTermination();
   2739          
   2740          		#if ( configUSE_PREEMPTION == 0 )
   2741          		{
   2742          			/* If we are not using preemption we keep forcing a task switch to
   2743          			see if any other task has become available.  If we are using
   2744          			preemption we don't need to do this as any task becoming available
   2745          			will automatically get the processor anyway. */
   2746          			taskYIELD();
   2747          		}
   2748          		#endif /* configUSE_PREEMPTION */
   2749          
   2750          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2751          		{
   2752          			/* When using preemption tasks of equal priority will be
   2753          			timesliced.  If a task that is sharing the idle priority is ready
   2754          			to run then the idle task should yield before the end of the
   2755          			timeslice.
   2756          
   2757          			A critical region is not required here as we are just reading from
   2758          			the list, and an occasional incorrect value will not matter.  If
   2759          			the ready list at the idle priority contains more than one task
   2760          			then a task other than the idle task is ready to execute. */
   2761          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   2762          			{
   2763          				taskYIELD();
   2764          			}
   2765          			else
   2766          			{
   2767          				mtCOVERAGE_TEST_MARKER();
   2768          			}
   2769          		}
   2770          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2771          
   2772          		#if ( configUSE_IDLE_HOOK == 1 )
   2773          		{
   2774          			extern void vApplicationIdleHook( void );
   2775          
   2776          			/* Call the user defined function from within the idle task.  This
   2777          			allows the application designer to add background functionality
   2778          			without the overhead of a separate task.
   2779          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2780          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2781          			vApplicationIdleHook();
   2782          		}
   2783          		#endif /* configUSE_IDLE_HOOK */
   2784          
   2785          		/* This conditional compilation should use inequality to 0, not equality
   2786          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2787          		user defined low power mode	implementations require
   2788          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2789          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2790          		{
   2791          		TickType_t xExpectedIdleTime;
   2792          
   2793          			/* It is not desirable to suspend then resume the scheduler on
   2794          			each iteration of the idle task.  Therefore, a preliminary
   2795          			test of the expected idle time is performed without the
   2796          			scheduler suspended.  The result here is not necessarily
   2797          			valid. */
   2798          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2799          
   2800          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2801          			{
   2802          				vTaskSuspendAll();
   2803          				{
   2804          					/* Now the scheduler is suspended, the expected idle
   2805          					time can be sampled again, and this time its value can
   2806          					be used. */
   2807          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2808          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2809          
   2810          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2811          					{
   2812          						traceLOW_POWER_IDLE_BEGIN();
   2813          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2814          						traceLOW_POWER_IDLE_END();
   2815          					}
   2816          					else
   2817          					{
   2818          						mtCOVERAGE_TEST_MARKER();
   2819          					}
   2820          				}
   2821          				( void ) xTaskResumeAll();
   2822          			}
   2823          			else
   2824          			{
   2825          				mtCOVERAGE_TEST_MARKER();
   2826          			}
   2827          		}
   2828          		#endif /* configUSE_TICKLESS_IDLE */
   2829          	}
   2830          }
   2831          /*-----------------------------------------------------------*/
   2832          
   2833          #if( configUSE_TICKLESS_IDLE != 0 )
   2834          
   2835          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2836          	{
   2837          	/* The idle task exists in addition to the application tasks. */
   2838          	const UBaseType_t uxNonApplicationTasks = 1;
   2839          	eSleepModeStatus eReturn = eStandardSleep;
   2840          
   2841          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2842          		{
   2843          			/* A task was made ready while the scheduler was suspended. */
   2844          			eReturn = eAbortSleep;
   2845          		}
   2846          		else if( xYieldPending != pdFALSE )
   2847          		{
   2848          			/* A yield was pended while the scheduler was suspended. */
   2849          			eReturn = eAbortSleep;
   2850          		}
   2851          		else
   2852          		{
   2853          			/* If all the tasks are in the suspended list (which might mean they
   2854          			have an infinite block time rather than actually being suspended)
   2855          			then it is safe to turn all clocks off and just wait for external
   2856          			interrupts. */
   2857          			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2858          			{
   2859          				eReturn = eNoTasksWaitingTimeout;
   2860          			}
   2861          			else
   2862          			{
   2863          				mtCOVERAGE_TEST_MARKER();
   2864          			}
   2865          		}
   2866          
   2867          		return eReturn;
   2868          	}
   2869          
   2870          #endif /* configUSE_TICKLESS_IDLE */
   2871          /*-----------------------------------------------------------*/
   2872          
   2873          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2874          {
   2875          UBaseType_t x;
   2876          
   2877          	/* Store the task name in the TCB. */
   2878          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2879          	{
   2880          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   2881          
   2882          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2883          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2884          		string is not accessible (extremely unlikely). */
   2885          		if( pcName[ x ] == 0x00 )
   2886          		{
   2887          			break;
   2888          		}
   2889          		else
   2890          		{
   2891          			mtCOVERAGE_TEST_MARKER();
   2892          		}
   2893          	}
   2894          
   2895          	/* Ensure the name string is terminated in the case that the string length
   2896          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2897          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2898          
   2899          	/* This is used as an array index so must ensure it's not too large.  First
   2900          	remove the privilege bit if one is present. */
   2901          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2902          	{
   2903          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2904          	}
   2905          	else
   2906          	{
   2907          		mtCOVERAGE_TEST_MARKER();
   2908          	}
   2909          
   2910          	pxTCB->uxPriority = uxPriority;
   2911          	#if ( configUSE_MUTEXES == 1 )
   2912          	{
   2913          		pxTCB->uxBasePriority = uxPriority;
   2914          		pxTCB->uxMutexesHeld = 0;
   2915          	}
   2916          	#endif /* configUSE_MUTEXES */
   2917          
   2918          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2919          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2920          
   2921          	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
   2922          	back to	the containing TCB from a generic item in a list. */
   2923          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2924          
   2925          	/* Event lists are always in priority order. */
   2926          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2927          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2928          
   2929          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2930          	{
   2931          		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   2932          	}
   2933          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2934          
   2935          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2936          	{
   2937          		pxTCB->pxTaskTag = NULL;
   2938          	}
   2939          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2940          
   2941          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2942          	{
   2943          		pxTCB->ulRunTimeCounter = 0UL;
   2944          	}
   2945          	#endif /* configGENERATE_RUN_TIME_STATS */
   2946          
   2947          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2948          	{
   2949          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2950          	}
   2951          	#else /* portUSING_MPU_WRAPPERS */
   2952          	{
   2953          		( void ) xRegions;
   2954          		( void ) usStackDepth;
   2955          	}
   2956          	#endif /* portUSING_MPU_WRAPPERS */
   2957          
   2958          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   2959          	{
   2960          		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
   2961          		{
   2962          			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
   2963          		}
   2964          	}
   2965          	#endif
   2966          
   2967          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
   2968          	{
   2969          		pxTCB->ulNotifiedValue = 0;
   2970          		pxTCB->eNotifyState = eNotWaitingNotification;
   2971          	}
   2972          	#endif
   2973          
   2974          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2975          	{
   2976          		/* Initialise this task's Newlib reent structure. */
   2977          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2978          	}
   2979          	#endif /* configUSE_NEWLIB_REENTRANT */
   2980          }
   2981          /*-----------------------------------------------------------*/
   2982          
   2983          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   2984          
   2985          	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
   2986          	{
   2987          	TCB_t *pxTCB;
   2988          
   2989          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   2990          		{
   2991          			pxTCB = prvGetTCBFromHandle( xTaskToSet );
   2992          			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   2993          		}
   2994          	}
   2995          
   2996          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   2997          /*-----------------------------------------------------------*/
   2998          
   2999          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3000          
   3001          	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
   3002          	{
   3003          	void *pvReturn = NULL;
   3004          	TCB_t *pxTCB;
   3005          
   3006          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   3007          		{
   3008          			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   3009          			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   3010          		}
   3011          		else
   3012          		{
   3013          			pvReturn = NULL;
   3014          		}
   3015          
   3016          		return pvReturn;
   3017          	}
   3018          
   3019          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3020          /*-----------------------------------------------------------*/
   3021          
   3022          #if ( portUSING_MPU_WRAPPERS == 1 )
   3023          
   3024          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   3025          	{
   3026          	TCB_t *pxTCB;
   3027          
   3028          		/* If null is passed in here then we are modifying the MPU settings of
   3029          		the calling task. */
   3030          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   3031          
   3032                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   3033          	}
   3034          
   3035          #endif /* portUSING_MPU_WRAPPERS */
   3036          /*-----------------------------------------------------------*/
   3037          
   3038          static void prvInitialiseTaskLists( void )
   3039          {
   3040          UBaseType_t uxPriority;
   3041          
   3042          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   3043          	{
   3044          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   3045          	}
   3046          
   3047          	vListInitialise( &xDelayedTaskList1 );
   3048          	vListInitialise( &xDelayedTaskList2 );
   3049          	vListInitialise( &xPendingReadyList );
   3050          
   3051          	#if ( INCLUDE_vTaskDelete == 1 )
   3052          	{
   3053          		vListInitialise( &xTasksWaitingTermination );
   3054          	}
   3055          	#endif /* INCLUDE_vTaskDelete */
   3056          
   3057          	#if ( INCLUDE_vTaskSuspend == 1 )
   3058          	{
   3059          		vListInitialise( &xSuspendedTaskList );
   3060          	}
   3061          	#endif /* INCLUDE_vTaskSuspend */
   3062          
   3063          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   3064          	using list2. */
   3065          	pxDelayedTaskList = &xDelayedTaskList1;
   3066          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   3067          }
   3068          /*-----------------------------------------------------------*/
   3069          
   3070          static void prvCheckTasksWaitingTermination( void )
   3071          {
   3072          	#if ( INCLUDE_vTaskDelete == 1 )
   3073          	{
   3074          		BaseType_t xListIsEmpty;
   3075          
   3076          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   3077          		too often in the idle task. */
   3078          		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   3079          		{
   3080          			vTaskSuspendAll();
   3081          			{
   3082          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   3083          			}
   3084          			( void ) xTaskResumeAll();
   3085          
   3086          			if( xListIsEmpty == pdFALSE )
   3087          			{
   3088          				TCB_t *pxTCB;
   3089          
   3090          				taskENTER_CRITICAL();
   3091          				{
   3092          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   3093          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   3094          					--uxCurrentNumberOfTasks;
   3095          					--uxDeletedTasksWaitingCleanUp;
   3096          				}
   3097          				taskEXIT_CRITICAL();
   3098          
   3099          				prvDeleteTCB( pxTCB );
   3100          			}
   3101          			else
   3102          			{
   3103          				mtCOVERAGE_TEST_MARKER();
   3104          			}
   3105          		}
   3106          	}
   3107          	#endif /* INCLUDE_vTaskDelete */
   3108          }
   3109          /*-----------------------------------------------------------*/
   3110          
   3111          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
   3112          {
   3113          	/* The list item will be inserted in wake time order. */
   3114          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   3115          
   3116          	if( xTimeToWake < xTickCount )
   3117          	{
   3118          		/* Wake time has overflowed.  Place this item in the overflow list. */
   3119          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3120          	}
   3121          	else
   3122          	{
   3123          		/* The wake time has not overflowed, so the current block list is used. */
   3124          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3125          
   3126          		/* If the task entering the blocked state was placed at the head of the
   3127          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   3128          		too. */
   3129          		if( xTimeToWake < xNextTaskUnblockTime )
   3130          		{
   3131          			xNextTaskUnblockTime = xTimeToWake;
   3132          		}
   3133          		else
   3134          		{
   3135          			mtCOVERAGE_TEST_MARKER();
   3136          		}
   3137          	}
   3138          }
   3139          /*-----------------------------------------------------------*/
   3140          
   3141          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer, TCB_t * const pxTCBBuffer )
   3142          {
   3143          TCB_t *pxNewTCB;
   3144          
   3145          	#if( configASSERT_DEFINED == 1 )
   3146          	{
   3147          		volatile size_t xSize = sizeof( DummyTCB_t );
   3148          		configASSERT( xSize == sizeof( TCB_t ) );
   3149          	}
   3150          	#endif /* configASSERT_DEFINED */
   3151          
   3152          	/* If the stack grows down then allocate the stack then the TCB so the stack
   3153          	does not grow into the TCB.  Likewise if the stack grows up then allocate
   3154          	the TCB then the stack. */
   3155          	#if( portSTACK_GROWTH > 0 )
   3156          	{
   3157          		/* Allocate space for the TCB.  Where the memory comes from depends on
   3158          		the implementation of the port malloc function. */
   3159          		pxNewTCB = ( TCB_t * ) pvPortMallocAligned( sizeof( TCB_t ), pxTCBBuffer );
   3160          
   3161          		if( pxNewTCB != NULL )
   3162          		{
   3163          			/* Allocate space for the stack used by the task being created.
   3164          			The base of the stack memory stored in the TCB so the task can
   3165          			be deleted later if required. */
   3166          			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3167          
   3168          			if( pxNewTCB->pxStack == NULL )
   3169          			{
   3170          				/* Could not allocate the stack.  Delete the allocated TCB - if
   3171          				it was allocated dynamically. */
   3172          				if( pxTCBBuffer == NULL )
   3173          				{
   3174          					vPortFree( pxNewTCB );
   3175          				}
   3176          				pxNewTCB = NULL;
   3177          			}
   3178          		}
   3179          	}
   3180          	#else /* portSTACK_GROWTH */
   3181          	{
   3182          	StackType_t *pxStack;
   3183          
   3184          		/* Allocate space for the stack used by the task being created. */
   3185          		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3186          
   3187          		if( pxStack != NULL )
   3188          		{
   3189          			/* Allocate space for the TCB. */
   3190          			pxNewTCB = ( TCB_t * ) pvPortMallocAligned( sizeof( TCB_t ), pxTCBBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   3191          
   3192          			if( pxNewTCB != NULL )
   3193          			{
   3194          				/* Store the stack location in the TCB. */
   3195          				pxNewTCB->pxStack = pxStack;
   3196          			}
   3197          			else
   3198          			{
   3199          				/* The stack cannot be used as the TCB was not created.  Free it
   3200          				again. */
   3201          				if( puxStackBuffer == NULL )
   3202          				{
   3203          					vPortFree( pxStack );
   3204          				}
   3205          				else
   3206          				{
   3207          					mtCOVERAGE_TEST_MARKER();
   3208          				}
   3209          			}
   3210          		}
   3211          		else
   3212          		{
   3213          			pxNewTCB = NULL;
   3214          		}
   3215          	}
   3216          	#endif /* portSTACK_GROWTH */
   3217          
   3218          	if( pxNewTCB != NULL )
   3219          	{
   3220          		/* Avoid dependency on memset() if it is not required. */
   3221          		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3222          		{
   3223          			/* Just to help debugging. */
   3224          			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   3225          		}
   3226          		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
   3227          
   3228          		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   3229          		{
   3230          			pxNewTCB->uxStaticAllocationFlags = 0;
   3231          
   3232          			if( puxStackBuffer != NULL )
   3233          			{
   3234          				/* The application provided its own stack - note the fact so no
   3235          				attempt is made to delete the stack if the task is deleted. */
   3236          				pxNewTCB->uxStaticAllocationFlags |= taskSTATICALLY_ALLOCATED_STACK;
   3237          			}
   3238          			else
   3239          			{
   3240          				mtCOVERAGE_TEST_MARKER();
   3241          			}
   3242          
   3243          			if( pxTCBBuffer != NULL )
   3244          			{
   3245          				/* The application provided its own TCB.  Note the fact so no
   3246          				attempt is made to delete the TCB if the task is deleted. */
   3247          				pxNewTCB->uxStaticAllocationFlags |= taskSTATICALLY_ALLOCATED_TCB;
   3248          			}
   3249          			else
   3250          			{
   3251          				mtCOVERAGE_TEST_MARKER();
   3252          			}
   3253          		}
   3254          		#endif /* configSUPPORT_STATIC_ALLOCATION */
   3255          	}
   3256          
   3257          	return pxNewTCB;
   3258          }
   3259          /*-----------------------------------------------------------*/
   3260          
   3261          #if ( configUSE_TRACE_FACILITY == 1 )
   3262          
   3263          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3264          	{
   3265          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   3266          	UBaseType_t uxTask = 0;
   3267          
   3268          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3269          		{
   3270          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   3271          
   3272          			/* Populate an TaskStatus_t structure within the
   3273          			pxTaskStatusArray array for each task that is referenced from
   3274          			pxList.  See the definition of TaskStatus_t in task.h for the
   3275          			meaning of each TaskStatus_t structure member. */
   3276          			do
   3277          			{
   3278          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   3279          
   3280          				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   3281          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   3282          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   3283          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   3284          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   3285          
   3286          				#if ( INCLUDE_vTaskSuspend == 1 )
   3287          				{
   3288          					/* If the task is in the suspended list then there is a chance
   3289          					it is actually just blocked indefinitely - so really it should
   3290          					be reported as being in the Blocked state. */
   3291          					if( eState == eSuspended )
   3292          					{
   3293          						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
   3294          						{
   3295          							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
   3296          						}
   3297          					}
   3298          				}
   3299          				#endif /* INCLUDE_vTaskSuspend */
   3300          
   3301          				#if ( configUSE_MUTEXES == 1 )
   3302          				{
   3303          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   3304          				}
   3305          				#else
   3306          				{
   3307          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   3308          				}
   3309          				#endif
   3310          
   3311          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3312          				{
   3313          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   3314          				}
   3315          				#else
   3316          				{
   3317          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   3318          				}
   3319          				#endif
   3320          
   3321          				#if ( portSTACK_GROWTH > 0 )
   3322          				{
   3323          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
   3324          				}
   3325          				#else
   3326          				{
   3327          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   3328          				}
   3329          				#endif
   3330          
   3331          				uxTask++;
   3332          
   3333          			} while( pxNextTCB != pxFirstTCB );
   3334          		}
   3335          		else
   3336          		{
   3337          			mtCOVERAGE_TEST_MARKER();
   3338          		}
   3339          
   3340          		return uxTask;
   3341          	}
   3342          
   3343          #endif /* configUSE_TRACE_FACILITY */
   3344          /*-----------------------------------------------------------*/
   3345          
   3346          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3347          
   3348          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3349          	{
   3350          	uint32_t ulCount = 0U;
   3351          
   3352          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3353          		{
   3354          			pucStackByte -= portSTACK_GROWTH;
   3355          			ulCount++;
   3356          		}
   3357          
   3358          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3359          
   3360          		return ( uint16_t ) ulCount;
   3361          	}
   3362          
   3363          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3364          /*-----------------------------------------------------------*/
   3365          
   3366          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3367          
   3368          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3369          	{
   3370          	TCB_t *pxTCB;
   3371          	uint8_t *pucEndOfStack;
   3372          	UBaseType_t uxReturn;
   3373          
   3374          		pxTCB = prvGetTCBFromHandle( xTask );
   3375          
   3376          		#if portSTACK_GROWTH < 0
   3377          		{
   3378          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3379          		}
   3380          		#else
   3381          		{
   3382          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3383          		}
   3384          		#endif
   3385          
   3386          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3387          
   3388          		return uxReturn;
   3389          	}
   3390          
   3391          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3392          /*-----------------------------------------------------------*/
   3393          
   3394          #if ( INCLUDE_vTaskDelete == 1 )
   3395          
   3396          	static void prvDeleteTCB( TCB_t *pxTCB )
   3397          	{
   3398          		/* This call is required specifically for the TriCore port.  It must be
   3399          		above the vPortFree() calls.  The call is also used by ports/demos that
   3400          		want to allocate and clean RAM statically. */
   3401          		portCLEAN_UP_TCB( pxTCB );
   3402          
   3403          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3404          		to the task to free any memory allocated at the application level. */
   3405          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3406          		{
   3407          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3408          		}
   3409          		#endif /* configUSE_NEWLIB_REENTRANT */
   3410          
   3411          		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   3412          		{
   3413          			/* Only free the stack and TCB if they were allocated dynamically in
   3414          			the first place. */
   3415          			if( ( pxTCB->uxStaticAllocationFlags & taskSTATICALLY_ALLOCATED_STACK ) == ( UBaseType_t ) 0 )
   3416          			{
   3417          				vPortFreeAligned( pxTCB->pxStack );
   3418          			}
   3419          			else
   3420          			{
   3421          				mtCOVERAGE_TEST_MARKER();
   3422          			}
   3423          
   3424          			if( ( pxTCB->uxStaticAllocationFlags & taskSTATICALLY_ALLOCATED_TCB ) == ( UBaseType_t ) 0 )
   3425          			{
   3426          				vPortFreeAligned( pxTCB );
   3427          			}
   3428          			else
   3429          			{
   3430          				mtCOVERAGE_TEST_MARKER();
   3431          			}
   3432          		}
   3433          		#else
   3434          		{
   3435          			vPortFreeAligned( pxTCB->pxStack );
   3436          			vPortFree( pxTCB );
   3437          		}
   3438          		#endif
   3439          	}
   3440          
   3441          #endif /* INCLUDE_vTaskDelete */
   3442          /*-----------------------------------------------------------*/
   3443          
   3444          static void prvResetNextTaskUnblockTime( void )
   3445          {
   3446          TCB_t *pxTCB;
   3447          
   3448          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3449          	{
   3450          		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   3451          		the maximum possible value so it is	extremely unlikely that the
   3452          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3453          		there is an item in the delayed list. */
   3454          		xNextTaskUnblockTime = portMAX_DELAY;
   3455          	}
   3456          	else
   3457          	{
   3458          		/* The new current delayed list is not empty, get the value of
   3459          		the item at the head of the delayed list.  This is the time at
   3460          		which the task at the head of the delayed list should be removed
   3461          		from the Blocked state. */
   3462          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3463          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   3464          	}
   3465          }
   3466          /*-----------------------------------------------------------*/
   3467          
   3468          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3469          
   3470          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3471          	{
   3472          	TaskHandle_t xReturn;
   3473          
   3474          		/* A critical section is not required as this is not called from
   3475          		an interrupt and the current TCB will always be the same for any
   3476          		individual execution thread. */
   3477          		xReturn = pxCurrentTCB;
   3478          
   3479          		return xReturn;
   3480          	}
   3481          
   3482          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3483          /*-----------------------------------------------------------*/
   3484          
   3485          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3486          
   3487          	BaseType_t xTaskGetSchedulerState( void )
   3488          	{
   3489          	BaseType_t xReturn;
   3490          
   3491          		if( xSchedulerRunning == pdFALSE )
   3492          		{
   3493          			xReturn = taskSCHEDULER_NOT_STARTED;
   3494          		}
   3495          		else
   3496          		{
   3497          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3498          			{
   3499          				xReturn = taskSCHEDULER_RUNNING;
   3500          			}
   3501          			else
   3502          			{
   3503          				xReturn = taskSCHEDULER_SUSPENDED;
   3504          			}
   3505          		}
   3506          
   3507          		return xReturn;
   3508          	}
   3509          
   3510          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3511          /*-----------------------------------------------------------*/
   3512          
   3513          #if ( configUSE_MUTEXES == 1 )
   3514          
   3515          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3516          	{
   3517          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3518          
   3519          		/* If the mutex was given back by an interrupt while the queue was
   3520          		locked then the mutex holder might now be NULL. */
   3521          		if( pxMutexHolder != NULL )
   3522          		{
   3523          			/* If the holder of the mutex has a priority below the priority of
   3524          			the task attempting to obtain the mutex then it will temporarily
   3525          			inherit the priority of the task attempting to obtain the mutex. */
   3526          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   3527          			{
   3528          				/* Adjust the mutex holder state to account for its new
   3529          				priority.  Only reset the event list item value if the value is
   3530          				not	being used for anything else. */
   3531          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3532          				{
   3533          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3534          				}
   3535          				else
   3536          				{
   3537          					mtCOVERAGE_TEST_MARKER();
   3538          				}
   3539          
   3540          				/* If the task being modified is in the ready state it will need
   3541          				to be moved into a new list. */
   3542          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   3543          				{
   3544          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3545          					{
   3546          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3547          					}
   3548          					else
   3549          					{
   3550          						mtCOVERAGE_TEST_MARKER();
   3551          					}
   3552          
   3553          					/* Inherit the priority before being moved into the new list. */
   3554          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3555          					prvAddTaskToReadyList( pxTCB );
   3556          				}
   3557          				else
   3558          				{
   3559          					/* Just inherit the priority. */
   3560          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3561          				}
   3562          
   3563          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3564          			}
   3565          			else
   3566          			{
   3567          				mtCOVERAGE_TEST_MARKER();
   3568          			}
   3569          		}
   3570          		else
   3571          		{
   3572          			mtCOVERAGE_TEST_MARKER();
   3573          		}
   3574          	}
   3575          
   3576          #endif /* configUSE_MUTEXES */
   3577          /*-----------------------------------------------------------*/
   3578          
   3579          #if ( configUSE_MUTEXES == 1 )
   3580          
   3581          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3582          	{
   3583          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3584          	BaseType_t xReturn = pdFALSE;
   3585          
   3586          		if( pxMutexHolder != NULL )
   3587          		{
   3588          			/* A task can only have an inherited priority if it holds the mutex.
   3589          			If the mutex is held by a task then it cannot be given from an
   3590          			interrupt, and if a mutex is given by the holding task then it must
   3591          			be the running state task. */
   3592          			configASSERT( pxTCB == pxCurrentTCB );
   3593          
   3594          			configASSERT( pxTCB->uxMutexesHeld );
   3595          			( pxTCB->uxMutexesHeld )--;
   3596          
   3597          			/* Has the holder of the mutex inherited the priority of another
   3598          			task? */
   3599          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3600          			{
   3601          				/* Only disinherit if no other mutexes are held. */
   3602          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3603          				{
   3604          					/* A task can only have an inherited priority if it holds
   3605          					the mutex.  If the mutex is held by a task then it cannot be
   3606          					given from an interrupt, and if a mutex is given by the
   3607          					holding	task then it must be the running state task.  Remove
   3608          					the	holding task from the ready	list. */
   3609          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3610          					{
   3611          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3612          					}
   3613          					else
   3614          					{
   3615          						mtCOVERAGE_TEST_MARKER();
   3616          					}
   3617          
   3618          					/* Disinherit the priority before adding the task into the
   3619          					new	ready list. */
   3620          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3621          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3622          
   3623          					/* Reset the event list item value.  It cannot be in use for
   3624          					any other purpose if this task is running, and it must be
   3625          					running to give back the mutex. */
   3626          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3627          					prvAddTaskToReadyList( pxTCB );
   3628          
   3629          					/* Return true to indicate that a context switch is required.
   3630          					This is only actually required in the corner case whereby
   3631          					multiple mutexes were held and the mutexes were given back
   3632          					in an order different to that in which they were taken.
   3633          					If a context switch did not occur when the first mutex was
   3634          					returned, even if a task was waiting on it, then a context
   3635          					switch should occur when the last mutex is returned whether
   3636          					a task is waiting on it or not. */
   3637          					xReturn = pdTRUE;
   3638          				}
   3639          				else
   3640          				{
   3641          					mtCOVERAGE_TEST_MARKER();
   3642          				}
   3643          			}
   3644          			else
   3645          			{
   3646          				mtCOVERAGE_TEST_MARKER();
   3647          			}
   3648          		}
   3649          		else
   3650          		{
   3651          			mtCOVERAGE_TEST_MARKER();
   3652          		}
   3653          
   3654          		return xReturn;
   3655          	}
   3656          
   3657          #endif /* configUSE_MUTEXES */
   3658          /*-----------------------------------------------------------*/
   3659          
   3660          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3661          
   3662          	void vTaskEnterCritical( void )
   3663          	{
   3664          		portDISABLE_INTERRUPTS();
   3665          
   3666          		if( xSchedulerRunning != pdFALSE )
   3667          		{
   3668          			( pxCurrentTCB->uxCriticalNesting )++;
   3669          
   3670          			/* This is not the interrupt safe version of the enter critical
   3671          			function so	assert() if it is being called from an interrupt
   3672          			context.  Only API functions that end in "FromISR" can be used in an
   3673          			interrupt.  Only assert if the critical nesting count is 1 to
   3674          			protect against recursive calls if the assert function also uses a
   3675          			critical section. */
   3676          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   3677          			{
   3678          				portASSERT_IF_IN_ISR();
   3679          			}
   3680          		}
   3681          		else
   3682          		{
   3683          			mtCOVERAGE_TEST_MARKER();
   3684          		}
   3685          	}
   3686          
   3687          #endif /* portCRITICAL_NESTING_IN_TCB */
   3688          /*-----------------------------------------------------------*/
   3689          
   3690          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3691          
   3692          	void vTaskExitCritical( void )
   3693          	{
   3694          		if( xSchedulerRunning != pdFALSE )
   3695          		{
   3696          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3697          			{
   3698          				( pxCurrentTCB->uxCriticalNesting )--;
   3699          
   3700          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3701          				{
   3702          					portENABLE_INTERRUPTS();
   3703          				}
   3704          				else
   3705          				{
   3706          					mtCOVERAGE_TEST_MARKER();
   3707          				}
   3708          			}
   3709          			else
   3710          			{
   3711          				mtCOVERAGE_TEST_MARKER();
   3712          			}
   3713          		}
   3714          		else
   3715          		{
   3716          			mtCOVERAGE_TEST_MARKER();
   3717          		}
   3718          	}
   3719          
   3720          #endif /* portCRITICAL_NESTING_IN_TCB */
   3721          /*-----------------------------------------------------------*/
   3722          
   3723          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3724          
   3725          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   3726          	{
   3727          	size_t x;
   3728          
   3729          		/* Start by copying the entire string. */
   3730          		strcpy( pcBuffer, pcTaskName );
   3731          
   3732          		/* Pad the end of the string with spaces to ensure columns line up when
   3733          		printed out. */
   3734          		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   3735          		{
   3736          			pcBuffer[ x ] = ' ';
   3737          		}
   3738          
   3739          		/* Terminate. */
   3740          		pcBuffer[ x ] = 0x00;
   3741          
   3742          		/* Return the new end of string. */
   3743          		return &( pcBuffer[ x ] );
   3744          	}
   3745          
   3746          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   3747          /*-----------------------------------------------------------*/
   3748          
   3749          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3750          
   3751          	void vTaskList( char * pcWriteBuffer )
   3752          	{
   3753          	TaskStatus_t *pxTaskStatusArray;
   3754          	volatile UBaseType_t uxArraySize, x;
   3755          	char cStatus;
   3756          
   3757          		/*
   3758          		 * PLEASE NOTE:
   3759          		 *
   3760          		 * This function is provided for convenience only, and is used by many
   3761          		 * of the demo applications.  Do not consider it to be part of the
   3762          		 * scheduler.
   3763          		 *
   3764          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3765          		 * uxTaskGetSystemState() output into a human readable table that
   3766          		 * displays task names, states and stack usage.
   3767          		 *
   3768          		 * vTaskList() has a dependency on the sprintf() C library function that
   3769          		 * might bloat the code size, use a lot of stack, and provide different
   3770          		 * results on different platforms.  An alternative, tiny, third party,
   3771          		 * and limited functionality implementation of sprintf() is provided in
   3772          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3773          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3774          		 * snprintf() implementation!).
   3775          		 *
   3776          		 * It is recommended that production systems call uxTaskGetSystemState()
   3777          		 * directly to get access to raw stats data, rather than indirectly
   3778          		 * through a call to vTaskList().
   3779          		 */
   3780          
   3781          
   3782          		/* Make sure the write buffer does not contain a string. */
   3783          		*pcWriteBuffer = 0x00;
   3784          
   3785          		/* Take a snapshot of the number of tasks in case it changes while this
   3786          		function is executing. */
   3787          		uxArraySize = uxCurrentNumberOfTasks;
   3788          
   3789          		/* Allocate an array index for each task. */
   3790          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3791          
   3792          		if( pxTaskStatusArray != NULL )
   3793          		{
   3794          			/* Generate the (binary) data. */
   3795          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3796          
   3797          			/* Create a human readable table from the binary data. */
   3798          			for( x = 0; x < uxArraySize; x++ )
   3799          			{
   3800          				switch( pxTaskStatusArray[ x ].eCurrentState )
   3801          				{
   3802          					case eReady:		cStatus = tskREADY_CHAR;
   3803          										break;
   3804          
   3805          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   3806          										break;
   3807          
   3808          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   3809          										break;
   3810          
   3811          					case eDeleted:		cStatus = tskDELETED_CHAR;
   3812          										break;
   3813          
   3814          					default:			/* Should not get here, but it is included
   3815          										to prevent static checking errors. */
   3816          										cStatus = 0x00;
   3817          										break;
   3818          				}
   3819          
   3820          				/* Write the task name to the string, padding with spaces so it
   3821          				can be printed in tabular form more easily. */
   3822          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3823          
   3824          				/* Write the rest of the string. */
   3825          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   3826          				pcWriteBuffer += strlen( pcWriteBuffer );
   3827          			}
   3828          
   3829          			/* Free the array again. */
   3830          			vPortFree( pxTaskStatusArray );
   3831          		}
   3832          		else
   3833          		{
   3834          			mtCOVERAGE_TEST_MARKER();
   3835          		}
   3836          	}
   3837          
   3838          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3839          /*----------------------------------------------------------*/
   3840          
   3841          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3842          
   3843          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   3844          	{
   3845          	TaskStatus_t *pxTaskStatusArray;
   3846          	volatile UBaseType_t uxArraySize, x;
   3847          	uint32_t ulTotalTime, ulStatsAsPercentage;
   3848          
   3849          		#if( configUSE_TRACE_FACILITY != 1 )
   3850          		{
   3851          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   3852          		}
   3853          		#endif
   3854          
   3855          		/*
   3856          		 * PLEASE NOTE:
   3857          		 *
   3858          		 * This function is provided for convenience only, and is used by many
   3859          		 * of the demo applications.  Do not consider it to be part of the
   3860          		 * scheduler.
   3861          		 *
   3862          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   3863          		 * of the uxTaskGetSystemState() output into a human readable table that
   3864          		 * displays the amount of time each task has spent in the Running state
   3865          		 * in both absolute and percentage terms.
   3866          		 *
   3867          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   3868          		 * function that might bloat the code size, use a lot of stack, and
   3869          		 * provide different results on different platforms.  An alternative,
   3870          		 * tiny, third party, and limited functionality implementation of
   3871          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   3872          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   3873          		 * a full snprintf() implementation!).
   3874          		 *
   3875          		 * It is recommended that production systems call uxTaskGetSystemState()
   3876          		 * directly to get access to raw stats data, rather than indirectly
   3877          		 * through a call to vTaskGetRunTimeStats().
   3878          		 */
   3879          
   3880          		/* Make sure the write buffer does not contain a string. */
   3881          		*pcWriteBuffer = 0x00;
   3882          
   3883          		/* Take a snapshot of the number of tasks in case it changes while this
   3884          		function is executing. */
   3885          		uxArraySize = uxCurrentNumberOfTasks;
   3886          
   3887          		/* Allocate an array index for each task. */
   3888          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3889          
   3890          		if( pxTaskStatusArray != NULL )
   3891          		{
   3892          			/* Generate the (binary) data. */
   3893          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   3894          
   3895          			/* For percentage calculations. */
   3896          			ulTotalTime /= 100UL;
   3897          
   3898          			/* Avoid divide by zero errors. */
   3899          			if( ulTotalTime > 0 )
   3900          			{
   3901          				/* Create a human readable table from the binary data. */
   3902          				for( x = 0; x < uxArraySize; x++ )
   3903          				{
   3904          					/* What percentage of the total run time has the task used?
   3905          					This will always be rounded down to the nearest integer.
   3906          					ulTotalRunTimeDiv100 has already been divided by 100. */
   3907          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   3908          
   3909          					/* Write the task name to the string, padding with
   3910          					spaces so it can be printed in tabular form more
   3911          					easily. */
   3912          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3913          
   3914          					if( ulStatsAsPercentage > 0UL )
   3915          					{
   3916          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3917          						{
   3918          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   3919          						}
   3920          						#else
   3921          						{
   3922          							/* sizeof( int ) == sizeof( long ) so a smaller
   3923          							printf() library can be used. */
   3924          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   3925          						}
   3926          						#endif
   3927          					}
   3928          					else
   3929          					{
   3930          						/* If the percentage is zero here then the task has
   3931          						consumed less than 1% of the total run time. */
   3932          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3933          						{
   3934          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   3935          						}
   3936          						#else
   3937          						{
   3938          							/* sizeof( int ) == sizeof( long ) so a smaller
   3939          							printf() library can be used. */
   3940          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   3941          						}
   3942          						#endif
   3943          					}
   3944          
   3945          					pcWriteBuffer += strlen( pcWriteBuffer );
   3946          				}
   3947          			}
   3948          			else
   3949          			{
   3950          				mtCOVERAGE_TEST_MARKER();
   3951          			}
   3952          
   3953          			/* Free the array again. */
   3954          			vPortFree( pxTaskStatusArray );
   3955          		}
   3956          		else
   3957          		{
   3958          			mtCOVERAGE_TEST_MARKER();
   3959          		}
   3960          	}
   3961          
   3962          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3963          /*-----------------------------------------------------------*/
   3964          
   3965          TickType_t uxTaskResetEventItemValue( void )
   3966          {
   3967          TickType_t uxReturn;
   3968          
   3969          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   3970          
   3971          	/* Reset the event list item to its normal value - so it can be used with
   3972          	queues and semaphores. */
   3973          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3974          
   3975          	return uxReturn;
   3976          }
   3977          /*-----------------------------------------------------------*/
   3978          
   3979          #if ( configUSE_MUTEXES == 1 )
   3980          
   3981          	void *pvTaskIncrementMutexHeldCount( void )
   3982          	{
   3983          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   3984          		then pxCurrentTCB will be NULL. */
   3985          		if( pxCurrentTCB != NULL )
   3986          		{
   3987          			( pxCurrentTCB->uxMutexesHeld )++;
   3988          		}
   3989          
   3990          		return pxCurrentTCB;
   3991          	}
   3992          
   3993          #endif /* configUSE_MUTEXES */
   3994          /*-----------------------------------------------------------*/
   3995          
   3996          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3997          
   3998          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   3999          	{
   4000          	TickType_t xTimeToWake;
   4001          	uint32_t ulReturn;
   4002          
   4003          		taskENTER_CRITICAL();
   4004          		{
   4005          			/* Only block if the notification count is not already non-zero. */
   4006          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   4007          			{
   4008          				/* Mark this task as waiting for a notification. */
   4009          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   4010          
   4011          				if( xTicksToWait > ( TickType_t ) 0 )
   4012          				{
   4013          					/* The task is going to block.  First it must be removed
   4014          					from the ready list. */
   4015          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   4016          					{
   4017          						/* The current task must be in a ready list, so there is
   4018          						no need to check, and the port reset macro can be called
   4019          						directly. */
   4020          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   4021          					}
   4022          					else
   4023          					{
   4024          						mtCOVERAGE_TEST_MARKER();
   4025          					}
   4026          
   4027          					#if ( INCLUDE_vTaskSuspend == 1 )
   4028          					{
   4029          						if( xTicksToWait == portMAX_DELAY )
   4030          						{
   4031          							/* Add the task to the suspended task list instead
   4032          							of a delayed task list to ensure the task is not
   4033          							woken by a timing event.  It will block
   4034          							indefinitely. */
   4035          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   4036          						}
   4037          						else
   4038          						{
   4039          							/* Calculate the time at which the task should be
   4040          							woken if no notification events occur.  This may
   4041          							overflow but this doesn't matter, the scheduler will
   4042          							handle it. */
   4043          							xTimeToWake = xTickCount + xTicksToWait;
   4044          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4045          						}
   4046          					}
   4047          					#else /* INCLUDE_vTaskSuspend */
   4048          					{
   4049          							/* Calculate the time at which the task should be
   4050          							woken if the event does not occur.  This may
   4051          							overflow but this doesn't matter, the scheduler will
   4052          							handle it. */
   4053          							xTimeToWake = xTickCount + xTicksToWait;
   4054          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4055          					}
   4056          					#endif /* INCLUDE_vTaskSuspend */
   4057          
   4058          					traceTASK_NOTIFY_TAKE_BLOCK();
   4059          
   4060          					/* All ports are written to allow a yield in a critical
   4061          					section (some will yield immediately, others wait until the
   4062          					critical section exits) - but it is not something that
   4063          					application code should ever do. */
   4064          					portYIELD_WITHIN_API();
   4065          				}
   4066          				else
   4067          				{
   4068          					mtCOVERAGE_TEST_MARKER();
   4069          				}
   4070          			}
   4071          			else
   4072          			{
   4073          				mtCOVERAGE_TEST_MARKER();
   4074          			}
   4075          		}
   4076          		taskEXIT_CRITICAL();
   4077          
   4078          		taskENTER_CRITICAL();
   4079          		{
   4080          			traceTASK_NOTIFY_TAKE();
   4081          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   4082          
   4083          			if( ulReturn != 0UL )
   4084          			{
   4085          				if( xClearCountOnExit != pdFALSE )
   4086          				{
   4087          					pxCurrentTCB->ulNotifiedValue = 0UL;
   4088          				}
   4089          				else
   4090          				{
   4091          					( pxCurrentTCB->ulNotifiedValue )--;
   4092          				}
   4093          			}
   4094          			else
   4095          			{
   4096          				mtCOVERAGE_TEST_MARKER();
   4097          			}
   4098          
   4099          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   4100          		}
   4101          		taskEXIT_CRITICAL();
   4102          
   4103          		return ulReturn;
   4104          	}
   4105          
   4106          #endif /* configUSE_TASK_NOTIFICATIONS */
   4107          /*-----------------------------------------------------------*/
   4108          
   4109          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4110          
   4111          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   4112          	{
   4113          	TickType_t xTimeToWake;
   4114          	BaseType_t xReturn;
   4115          
   4116          		taskENTER_CRITICAL();
   4117          		{
   4118          			/* Only block if a notification is not already pending. */
   4119          			if( pxCurrentTCB->eNotifyState != eNotified )
   4120          			{
   4121          				/* Clear bits in the task's notification value as bits may get
   4122          				set	by the notifying task or interrupt.  This can be used to
   4123          				clear the value to zero. */
   4124          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   4125          
   4126          				/* Mark this task as waiting for a notification. */
   4127          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   4128          
   4129          				if( xTicksToWait > ( TickType_t ) 0 )
   4130          				{
   4131          					/* The task is going to block.  First it must be removed
   4132          					from the	ready list. */
   4133          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   4134          					{
   4135          						/* The current task must be in a ready list, so there is
   4136          						no need to check, and the port reset macro can be called
   4137          						directly. */
   4138          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   4139          					}
   4140          					else
   4141          					{
   4142          						mtCOVERAGE_TEST_MARKER();
   4143          					}
   4144          
   4145          					#if ( INCLUDE_vTaskSuspend == 1 )
   4146          					{
   4147          						if( xTicksToWait == portMAX_DELAY )
   4148          						{
   4149          							/* Add the task to the suspended task list instead
   4150          							of a delayed task list to ensure the task is not
   4151          							woken by a timing event.  It will block
   4152          							indefinitely. */
   4153          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   4154          						}
   4155          						else
   4156          						{
   4157          							/* Calculate the time at which the task should be
   4158          							woken if no notification events occur.  This may
   4159          							overflow but this doesn't matter, the scheduler will
   4160          							handle it. */
   4161          							xTimeToWake = xTickCount + xTicksToWait;
   4162          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4163          						}
   4164          					}
   4165          					#else /* INCLUDE_vTaskSuspend */
   4166          					{
   4167          							/* Calculate the time at which the task should be
   4168          							woken if the event does not occur.  This may
   4169          							overflow but this doesn't matter, the scheduler will
   4170          							handle it. */
   4171          							xTimeToWake = xTickCount + xTicksToWait;
   4172          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4173          					}
   4174          					#endif /* INCLUDE_vTaskSuspend */
   4175          
   4176          					traceTASK_NOTIFY_WAIT_BLOCK();
   4177          
   4178          					/* All ports are written to allow a yield in a critical
   4179          					section (some will yield immediately, others wait until the
   4180          					critical section exits) - but it is not something that
   4181          					application code should ever do. */
   4182          					portYIELD_WITHIN_API();
   4183          				}
   4184          				else
   4185          				{
   4186          					mtCOVERAGE_TEST_MARKER();
   4187          				}
   4188          			}
   4189          			else
   4190          			{
   4191          				mtCOVERAGE_TEST_MARKER();
   4192          			}
   4193          		}
   4194          		taskEXIT_CRITICAL();
   4195          
   4196          		taskENTER_CRITICAL();
   4197          		{
   4198          			traceTASK_NOTIFY_WAIT();
   4199          
   4200          			if( pulNotificationValue != NULL )
   4201          			{
   4202          				/* Output the current notification value, which may or may not
   4203          				have changed. */
   4204          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   4205          			}
   4206          
   4207          			/* If eNotifyValue is set then either the task never entered the
   4208          			blocked state (because a notification was already pending) or the
   4209          			task unblocked because of a notification.  Otherwise the task
   4210          			unblocked because of a timeout. */
   4211          			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
   4212          			{
   4213          				/* A notification was not received. */
   4214          				xReturn = pdFALSE;
   4215          			}
   4216          			else
   4217          			{
   4218          				/* A notification was already pending or a notification was
   4219          				received while the task was waiting. */
   4220          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   4221          				xReturn = pdTRUE;
   4222          			}
   4223          
   4224          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   4225          		}
   4226          		taskEXIT_CRITICAL();
   4227          
   4228          		return xReturn;
   4229          	}
   4230          
   4231          #endif /* configUSE_TASK_NOTIFICATIONS */
   4232          /*-----------------------------------------------------------*/
   4233          
   4234          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4235          
   4236          	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
   4237          	{
   4238          	TCB_t * pxTCB;
   4239          	eNotifyValue eOriginalNotifyState;
   4240          	BaseType_t xReturn = pdPASS;
   4241          
   4242          		configASSERT( xTaskToNotify );
   4243          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4244          
   4245          		taskENTER_CRITICAL();
   4246          		{
   4247          			if( pulPreviousNotificationValue != NULL )
   4248          			{
   4249          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4250          			}
   4251          
   4252          			eOriginalNotifyState = pxTCB->eNotifyState;
   4253          
   4254          			pxTCB->eNotifyState = eNotified;
   4255          
   4256          			switch( eAction )
   4257          			{
   4258          				case eSetBits	:
   4259          					pxTCB->ulNotifiedValue |= ulValue;
   4260          					break;
   4261          
   4262          				case eIncrement	:
   4263          					( pxTCB->ulNotifiedValue )++;
   4264          					break;
   4265          
   4266          				case eSetValueWithOverwrite	:
   4267          					pxTCB->ulNotifiedValue = ulValue;
   4268          					break;
   4269          
   4270          				case eSetValueWithoutOverwrite :
   4271          					if( eOriginalNotifyState != eNotified )
   4272          					{
   4273          						pxTCB->ulNotifiedValue = ulValue;
   4274          					}
   4275          					else
   4276          					{
   4277          						/* The value could not be written to the task. */
   4278          						xReturn = pdFAIL;
   4279          					}
   4280          					break;
   4281          
   4282          				case eNoAction:
   4283          					/* The task is being notified without its notify value being
   4284          					updated. */
   4285          					break;
   4286          			}
   4287          
   4288          			traceTASK_NOTIFY();
   4289          
   4290          			/* If the task is in the blocked state specifically to wait for a
   4291          			notification then unblock it now. */
   4292          			if( eOriginalNotifyState == eWaitingNotification )
   4293          			{
   4294          				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4295          				prvAddTaskToReadyList( pxTCB );
   4296          
   4297          				/* The task should not have been on an event list. */
   4298          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4299          
   4300          				#if( configUSE_TICKLESS_IDLE != 0 )
   4301          				{
   4302          					/* If a task is blocked waiting for a notification then
   4303          					xNextTaskUnblockTime might be set to the blocked task's time
   4304          					out time.  If the task is unblocked for a reason other than
   4305          					a timeout xNextTaskUnblockTime is normally left unchanged,
   4306          					because it will automatically get reset to a new value when
   4307          					the tick count equals xNextTaskUnblockTime.  However if
   4308          					tickless idling is used it might be more important to enter
   4309          					sleep mode at the earliest possible time - so reset
   4310          					xNextTaskUnblockTime here to ensure it is updated at the
   4311          					earliest possible time. */
   4312          					prvResetNextTaskUnblockTime();
   4313          				}
   4314          				#endif
   4315          
   4316          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4317          				{
   4318          					/* The notified task has a priority above the currently
   4319          					executing task so a yield is required. */
   4320          					taskYIELD_IF_USING_PREEMPTION();
   4321          				}
   4322          				else
   4323          				{
   4324          					mtCOVERAGE_TEST_MARKER();
   4325          				}
   4326          			}
   4327          			else
   4328          			{
   4329          				mtCOVERAGE_TEST_MARKER();
   4330          			}
   4331          		}
   4332          		taskEXIT_CRITICAL();
   4333          
   4334          		return xReturn;
   4335          	}
   4336          
   4337          #endif /* configUSE_TASK_NOTIFICATIONS */
   4338          /*-----------------------------------------------------------*/
   4339          
   4340          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4341          
   4342          	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
   4343          	{
   4344          	TCB_t * pxTCB;
   4345          	eNotifyValue eOriginalNotifyState;
   4346          	BaseType_t xReturn = pdPASS;
   4347          	UBaseType_t uxSavedInterruptStatus;
   4348          
   4349          		configASSERT( xTaskToNotify );
   4350          
   4351          		/* RTOS ports that support interrupt nesting have the concept of a
   4352          		maximum	system call (or maximum API call) interrupt priority.
   4353          		Interrupts that are	above the maximum system call priority are keep
   4354          		permanently enabled, even when the RTOS kernel is in a critical section,
   4355          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4356          		is defined in FreeRTOSConfig.h then
   4357          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4358          		failure if a FreeRTOS API function is called from an interrupt that has
   4359          		been assigned a priority above the configured maximum system call
   4360          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4361          		from interrupts	that have been assigned a priority at or (logically)
   4362          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4363          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4364          		simple as possible.  More information (albeit Cortex-M specific) is
   4365          		provided on the following link:
   4366          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4367          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4368          
   4369          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4370          
   4371          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4372          		{
   4373          			if( pulPreviousNotificationValue != NULL )
   4374          			{
   4375          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4376          			}
   4377          
   4378          			eOriginalNotifyState = pxTCB->eNotifyState;
   4379          			pxTCB->eNotifyState = eNotified;
   4380          
   4381          			switch( eAction )
   4382          			{
   4383          				case eSetBits	:
   4384          					pxTCB->ulNotifiedValue |= ulValue;
   4385          					break;
   4386          
   4387          				case eIncrement	:
   4388          					( pxTCB->ulNotifiedValue )++;
   4389          					break;
   4390          
   4391          				case eSetValueWithOverwrite	:
   4392          					pxTCB->ulNotifiedValue = ulValue;
   4393          					break;
   4394          
   4395          				case eSetValueWithoutOverwrite :
   4396          					if( eOriginalNotifyState != eNotified )
   4397          					{
   4398          						pxTCB->ulNotifiedValue = ulValue;
   4399          					}
   4400          					else
   4401          					{
   4402          						/* The value could not be written to the task. */
   4403          						xReturn = pdFAIL;
   4404          					}
   4405          					break;
   4406          
   4407          				case eNoAction :
   4408          					/* The task is being notified without its notify value being
   4409          					updated. */
   4410          					break;
   4411          			}
   4412          
   4413          			traceTASK_NOTIFY_FROM_ISR();
   4414          
   4415          			/* If the task is in the blocked state specifically to wait for a
   4416          			notification then unblock it now. */
   4417          			if( eOriginalNotifyState == eWaitingNotification )
   4418          			{
   4419          				/* The task should not have been on an event list. */
   4420          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4421          
   4422          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4423          				{
   4424          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4425          					prvAddTaskToReadyList( pxTCB );
   4426          				}
   4427          				else
   4428          				{
   4429          					/* The delayed and ready lists cannot be accessed, so hold
   4430          					this task pending until the scheduler is resumed. */
   4431          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4432          				}
   4433          
   4434          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4435          				{
   4436          					/* The notified task has a priority above the currently
   4437          					executing task so a yield is required. */
   4438          					if( pxHigherPriorityTaskWoken != NULL )
   4439          					{
   4440          						*pxHigherPriorityTaskWoken = pdTRUE;
   4441          					}
   4442          					else
   4443          					{
   4444          						/* Mark that a yield is pending in case the user is not
   4445          						using the "xHigherPriorityTaskWoken" parameter to an ISR
   4446          						safe FreeRTOS function. */
   4447          						xYieldPending = pdTRUE;
   4448          					}
   4449          				}
   4450          				else
   4451          				{
   4452          					mtCOVERAGE_TEST_MARKER();
   4453          				}
   4454          			}
   4455          		}
   4456          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4457          
   4458          		return xReturn;
   4459          	}
   4460          
   4461          #endif /* configUSE_TASK_NOTIFICATIONS */
   4462          /*-----------------------------------------------------------*/
   4463          
   4464          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4465          
   4466          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4467          	{
   4468          	TCB_t * pxTCB;
   4469          	eNotifyValue eOriginalNotifyState;
   4470          	UBaseType_t uxSavedInterruptStatus;
   4471          
   4472          		configASSERT( xTaskToNotify );
   4473          
   4474          		/* RTOS ports that support interrupt nesting have the concept of a
   4475          		maximum	system call (or maximum API call) interrupt priority.
   4476          		Interrupts that are	above the maximum system call priority are keep
   4477          		permanently enabled, even when the RTOS kernel is in a critical section,
   4478          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4479          		is defined in FreeRTOSConfig.h then
   4480          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4481          		failure if a FreeRTOS API function is called from an interrupt that has
   4482          		been assigned a priority above the configured maximum system call
   4483          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4484          		from interrupts	that have been assigned a priority at or (logically)
   4485          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4486          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4487          		simple as possible.  More information (albeit Cortex-M specific) is
   4488          		provided on the following link:
   4489          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4490          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4491          
   4492          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4493          
   4494          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4495          		{
   4496          			eOriginalNotifyState = pxTCB->eNotifyState;
   4497          			pxTCB->eNotifyState = eNotified;
   4498          
   4499          			/* 'Giving' is equivalent to incrementing a count in a counting
   4500          			semaphore. */
   4501          			( pxTCB->ulNotifiedValue )++;
   4502          
   4503          			traceTASK_NOTIFY_GIVE_FROM_ISR();
   4504          
   4505          			/* If the task is in the blocked state specifically to wait for a
   4506          			notification then unblock it now. */
   4507          			if( eOriginalNotifyState == eWaitingNotification )
   4508          			{
   4509          				/* The task should not have been on an event list. */
   4510          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4511          
   4512          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4513          				{
   4514          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   4515          					prvAddTaskToReadyList( pxTCB );
   4516          				}
   4517          				else
   4518          				{
   4519          					/* The delayed and ready lists cannot be accessed, so hold
   4520          					this task pending until the scheduler is resumed. */
   4521          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4522          				}
   4523          
   4524          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4525          				{
   4526          					/* The notified task has a priority above the currently
   4527          					executing task so a yield is required. */
   4528          					if( pxHigherPriorityTaskWoken != NULL )
   4529          					{
   4530          						*pxHigherPriorityTaskWoken = pdTRUE;
   4531          					}
   4532          					else
   4533          					{
   4534          						/* Mark that a yield is pending in case the user is not
   4535          						using the "xHigherPriorityTaskWoken" parameter in an ISR
   4536          						safe FreeRTOS function. */
   4537          						xYieldPending = pdTRUE;
   4538          					}
   4539          				}
   4540          				else
   4541          				{
   4542          					mtCOVERAGE_TEST_MARKER();
   4543          				}
   4544          			}
   4545          		}
   4546          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4547          	}
   4548          
   4549          #endif /* configUSE_TASK_NOTIFICATIONS */
   4550          
   4551          /*-----------------------------------------------------------*/
   4552          
   4553          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4554          
   4555          	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
   4556          	{
   4557          	TCB_t *pxTCB;
   4558          	BaseType_t xReturn;
   4559          
   4560          		/* If null is passed in here then it is the calling task that is having
   4561          		its notification state cleared. */
   4562          		pxTCB = prvGetTCBFromHandle( xTask );
   4563          
   4564          		taskENTER_CRITICAL();
   4565          		{
   4566          			if( pxTCB->eNotifyState == eNotified )
   4567          			{
   4568          				pxTCB->eNotifyState = eNotWaitingNotification;
   4569          				xReturn = pdPASS;
   4570          			}
   4571          			else
   4572          			{
   4573          				xReturn = pdFAIL;
   4574          			}
   4575          		}
   4576          		taskEXIT_CRITICAL();
   4577          
   4578          		return xReturn;
   4579          	}
   4580          
   4581          #endif /* configUSE_TASK_NOTIFICATIONS */
   4582          /*-----------------------------------------------------------*/
   4583          
   4584          
   4585          #ifdef FREERTOS_MODULE_TEST
   4586          	#include "tasks_test_access_functions.h"
   4587          #endif
   4588          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  prvAddCurrentTaskToDelayedList
              8 -> vListInsert
       16  prvAllocateTCBAndStack
             16 -> pvPortMalloc
             16 -> vPortFree
       16  prvCheckTasksWaitingTermination
             16 -> prvDeleteTCB
             16 -> uxListRemove
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vTaskSuspendAll
             16 -> xTaskResumeAll
        8  prvDeleteTCB
              8 -> vPortFree
        0  prvIdleTask
              0 -> prvCheckTasksWaitingTermination
              0 -> vPortYield
       16  prvInitialiseTCBVariables
             16 -> vListInitialiseItem
        8  prvInitialiseTaskLists
              8 -> vListInitialise
        0  prvResetNextTaskUnblockTime
        0  prvTaskIsTaskSuspended
       16  ulTaskNotifyTake
             16 -> prvAddCurrentTaskToDelayedList
             16 -> uxListRemove
             16 -> vListInsertEnd
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vPortYield
        0  uxTaskGetNumberOfTasks
        8  uxTaskPriorityGet
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
        8  uxTaskPriorityGetFromISR
              8 -> ulPortSetInterruptMask
              8 -> vPortClearInterruptMask
        0  uxTaskResetEventItemValue
        8  vTaskDelay
              8 -> prvAddCurrentTaskToDelayedList
              8 -> uxListRemove
              8 -> vPortYield
              8 -> vTaskSuspendAll
              8 -> xTaskResumeAll
       16  vTaskDelayUntil
             16 -> prvAddCurrentTaskToDelayedList
             16 -> uxListRemove
             16 -> vPortYield
             16 -> vTaskSuspendAll
             16 -> xTaskResumeAll
        8  vTaskDelete
              8 -> prvDeleteTCB
              8 -> prvResetNextTaskUnblockTime
              8 -> uxListRemove
              8 -> vListInsertEnd
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
              8 -> vPortYield
        8  vTaskEndScheduler
              8 -> ulPortSetInterruptMask
              8 -> vPortEndScheduler
        0  vTaskMissedYield
       24  vTaskNotifyGiveFromISR
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortClearInterruptMask
        8  vTaskPlaceOnEventList
              8 -> prvAddCurrentTaskToDelayedList
              8 -> uxListRemove
              8 -> vListInsert
              8 -> vListInsertEnd
        8  vTaskPlaceOnUnorderedEventList
              8 -> prvAddCurrentTaskToDelayedList
              8 -> uxListRemove
              8 -> vListInsertEnd
       24  vTaskPrioritySet
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> vPortYield
       16  vTaskResume
             16 -> prvTaskIsTaskSuspended
             16 -> uxListRemove
             16 -> vListInsertEnd
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vPortYield
        0  vTaskSetTimeOutState
       24  vTaskStartScheduler
             24 -> ulPortSetInterruptMask
             24 -> xPortStartScheduler
             24 -> xTaskGenericCreate
        8  vTaskSuspend
              8 -> prvResetNextTaskUnblockTime
              8 -> uxListRemove
              8 -> vListInsertEnd
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
              8 -> vPortYield
              8 -> vTaskSwitchContext
        0  vTaskSuspendAll
        0  vTaskSwitchContext
       16  xTaskCheckForTimeOut
             16 -> vPortEnterCritical
             16 -> vPortExitCritical
             16 -> vTaskSetTimeOutState
       40  xTaskGenericCreate
             40 -> prvAllocateTCBAndStack
             40 -> prvInitialiseTCBVariables
             40 -> prvInitialiseTaskLists
             40 -> pxPortInitialiseStack
             40 -> vListInsertEnd
             40 -> vPortEnterCritical
             40 -> vPortExitCritical
             40 -> vPortYield
       24  xTaskGenericNotify
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> vPortYield
       32  xTaskGenericNotifyFromISR
             32 -> ulPortSetInterruptMask
             32 -> uxListRemove
             32 -> vListInsertEnd
             32 -> vPortClearInterruptMask
        0  xTaskGetTickCount
        0  xTaskGetTickCountFromISR
       16  xTaskIncrementTick
             16 -> prvResetNextTaskUnblockTime
             16 -> uxListRemove
             16 -> vListInsertEnd
        8  xTaskNotifyStateClear
              8 -> vPortEnterCritical
              8 -> vPortExitCritical
       24  xTaskNotifyWait
             24 -> prvAddCurrentTaskToDelayedList
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> vPortYield
       16  xTaskRemoveFromEventList
             16 -> uxListRemove
             16 -> vListInsertEnd
       16  xTaskRemoveFromUnorderedEventList
             16 -> uxListRemove
             16 -> vListInsertEnd
       24  xTaskResumeAll
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortEnterCritical
             24 -> vPortExitCritical
             24 -> vPortYield
             24 -> xTaskIncrementTick
       24  xTaskResumeFromISR
             24 -> prvTaskIsTaskSuspended
             24 -> ulPortSetInterruptMask
             24 -> uxListRemove
             24 -> vListInsertEnd
             24 -> vPortClearInterruptMask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "IDLE">
       4  ??DataTable29
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable30_3
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable37
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_14
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
      70  prvAddCurrentTaskToDelayedList
      68  prvAllocateTCBAndStack
      90  prvCheckTasksWaitingTermination
      18  prvDeleteTCB
      20  prvIdleTask
      80  prvInitialiseTCBVariables
      84  prvInitialiseTaskLists
      44  prvResetNextTaskUnblockTime
      34  prvTaskIsTaskSuspended
       4  pxCurrentTCB
       4  pxDelayedTaskList
       4  pxOverflowDelayedTaskList
     100  pxReadyTasksLists
     176  ulTaskNotifyTake
       4  uxCurrentNumberOfTasks
       4  uxDeletedTasksWaitingCleanUp
       4  uxPendedTicks
       4  uxSchedulerSuspended
       8  uxTaskGetNumberOfTasks
       4  uxTaskNumber
      30  uxTaskPriorityGet
      30  uxTaskPriorityGetFromISR
      30  uxTaskResetEventItemValue
       4  uxTopReadyPriority
      84  vTaskDelay
     122  vTaskDelayUntil
     196  vTaskDelete
      20  vTaskEndScheduler
      10  vTaskMissedYield
     130  vTaskNotifyGiveFromISR
      92  vTaskPlaceOnEventList
     104  vTaskPlaceOnUnorderedEventList
     190  vTaskPrioritySet
     102  vTaskResume
      18  vTaskSetTimeOutState
      86  vTaskStartScheduler
     178  vTaskSuspend
      16  vTaskSuspendAll
      86  vTaskSwitchContext
      20  xDelayedTaskList1
      20  xDelayedTaskList2
       4  xIdleTaskHandle
       4  xNextTaskUnblockTime
       4  xNumOfOverflows
      20  xPendingReadyList
       4  xSchedulerRunning
      20  xSuspendedTaskList
      88  xTaskCheckForTimeOut
     276  xTaskGenericCreate
     166  xTaskGenericNotify
     212  xTaskGenericNotifyFromISR
       8  xTaskGetTickCount
      10  xTaskGetTickCountFromISR
     270  xTaskIncrementTick
      46  xTaskNotifyStateClear
     184  xTaskNotifyWait
     108  xTaskRemoveFromEventList
      84  xTaskRemoveFromUnorderedEventList
     216  xTaskResumeAll
     118  xTaskResumeFromISR
      20  xTasksWaitingTermination
       4  xTickCount
       4  xYieldPending

 
   260 bytes in section .bss
     8 bytes in section .rodata
 4 110 bytes in section .text
 
 4 110 bytes of CODE  memory
     8 bytes of CONST memory
   260 bytes of DATA  memory

Errors: none
Warnings: none
